<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

## Невытесняющее планирование

---
# Диаграммы

Процесс:

```asciidrawing

         +-------------------------------+
---------+                               +----.....->
         +-------------------------------+          t
         |                               |
         main() -- включение             exit() -- выключение
```

Пользовательская сессия:

```
$ app1
$ app2
$ app3 ; app4
```

```asciidrawing

         Шелл  Задача 1  Шелл  Задача 2
         |     |         |     |
         +-----+---------+-----+---------+
---------+     |         |     |         +----.....->
         +-----+---------+-----+---------+          t
```

---
# Планирование

.def[Планирование] - распределение временного ресурса процессора(ов);
процесс определения, какой пользовательский процесс или поток (задача) будут исполняться.

Литература:
* Таненбаум, Современные ОС, 2.4

Пакетный режим:

```asciidrawing

         Задача 1     Задача 2    ...
         |            |           |
         +------------+-----------+---------
---------+            |           |         ......->
         +------------+-----------+---------       t
         |
         Включение
```

Планирование: можно ли извлечь выгоду изменением порядка задач?

---
# Невытесняющее планирование

.def[Невытесняющее планирование] - планирование, при котором следующая задача выбирается по завершению предыдущей

.def[Планировщик] - модуль ОС, отвечающий за планирование задач (процессов)

Планировщик:
 * Очередь задач и механизм её поддержания (одно/двусвязный список, куча, ...)
 * Политики определения следущей задачи

---
# Задача

Задача:
 * Окружение ОС (если нужно, например):
  * таблица файловых дескрипторов
  * имя приложения на диске
  * адрес функции входа
  * ...
 * Состояние:
  * готова (для исполнения)
  * выполняется
  * завершена

Вызовы планировщика:
 * добавить новую задачу
 * текущая задача завершается, удалить её из очереди, запустить новую задачу (`exit()`)

---
# Реализация

Очередь - (дву)связный список:
 * queue.h (BSD)
 * list.h (Linux)
 * dlist/slist (Embox)


Состояние может быть представлено неявно:

состояние | представление
---|---
готова | в очереди, не первая
выполняется | первая в очереди
завершена | не в очереди

---
# Политика

.def[Политика] - алгоритм выбора следующей задачи

 * FIFO
 * Наиболее короткая сначала: (добавляем "время работы" к задаче)

```
t10: task1
t20: task2
```

Важно: уменьшаем среднее время отклика

 * Наиболее приоритетная сначала:

.def[Приоритет] - абстрактное значение, обозначающее важность для пользователя.
```
p10: task1
p20: task2
```

 * С учётом принадлежности пользователю:

```
task1 (petya)
task2 (petya)
task3 (vasya)
```
---
# Политика

 * С указанием крайнего времени завершения (deadline)

```
d10: task1
d20: task2
```

Нетривиальные политики должны уметь:
 * либо получать информацию о задачах заранее
 * либо получать задачи и откладывать их

Невытесняющее планирование:
 * вызывается относительно редко
 * политика определяет расписание на достаточно долгое время (long-term scheduling)
 * выбор нельзя отменить, к политике предъявляются определённые требования оптимальности

---
# Наблюдение

```asciidrawing
   main                                       +--+
   |                                          |##| в ядре
   +--+----------....----+--+---------        +--+
---+  |##########....####|  |#########...->
   +--+----------....----+--+---------    t   +--+
      |                     |                 |  | в пользовательском
      read                  read              +--+ режиме



```

В ядре (`read`):
* Запрос к оборудованию
* Ожидание результата
* Выход из системного вызова

```c
request()
while (!hw_ready()) {
	microsleep();
}
```

Это .def[активное ожидание]

---
# Пассивное ожидание

```asciidrawing

   main                irq
   |                   |
   +--+--+             +--+--+
---+  |##+-------------+##|  +---...>
   +--+--+             +--+--+      t
      |
      read

```
```c

bool done = false;
void irq_handler(void) {
        done = true;
}

set_irq_handler(&irq_handler);
request()
while (!done) {
        yield(); // переводит процессор в режим пониженного
                 // энергопотребления.
                 // В UNIX: `pause(2)`
}
```

---
# Кооперативное планирование

Разбить приложение на набор зависимых задач.
```c
int main() {
	int ret = read(0, buf, sizeof(buf);
	...
}
```
```asciidrawing
        ||
        \/
```

```c
void main() {
	aread(0, buf, sizeof(buf), &readcont);
}

void readcont(int ret, char *buf, size_t size) {
	...
}
```

Пример: `aio(7)`

---
# Реализация

Новые состояния задачи:
 * завершена
 * ожидает (не в очереди + бит отличия от "выполнена")

состояние | представление
---|---
завершена | не в очереди
ожидает | не в очереди + бит отличия


Новые вызовы планировщика:
 * добавить новую ожидающую задачу
 * разбудить задачу ("ожидает" -> "готова")

---
# Кооперативное планирование

```asciidrawing
   main
   |
   +--+--+                  +--
---+  |##+------------------+  ......>
   +--+--+                  +--      t
      |           ^
      read        |
                  |(относится к 1й задаче)
                  |
         main    irq
         |       |
         +-------+--+---+---+
---------+       |##|   |###+-----...>
         +-------+--+---+---+        t
                        |
                        read
```
```c
void irq_handler(task) {
	wake(task);
}

add_waiting_task(&task);
set_irq_handler(&irq_handler, &task);
request()
```
---
# Кооперативные политики

Кооперативные политики учитывают принадлежность задач к процессам:
* round-robin: выполнять различные процессы по порядку
* наименьшее _оставшееся_ время
* динамический приоритет (класс политик, накапливать статистику выполнения)
  - честная политика: стараться распределять время согласно соотношению приоритетов
  - многоуровневая очередь: позволяет выбрать разные политики для эквивалентных процессов

Кооперативная политика вызывается намного чаще пакетной.

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
