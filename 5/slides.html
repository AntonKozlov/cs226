<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Невытесняющее планирование

---
# Планирование

.def[Планирование] - распределение временного ресурса процессора(ов);
процесс определения, какой пользовательский процесс или поток (задача) будут исполняться.

Таненбаум, Современные ОС, 2.4
---
# Текущее состояние

```asciidrawing

         Шелл  Задача 1  Шелл  Задача 2
         |     |         |     |
         +-----+---------+-----+---------+
---------+     |         |     |         +----......>
         +-----+---------+-----+---------+          t
         |
         Включение
```
Реализовать "`app1 | app2`" в такой ОС невозможно:
 * генерация большого количества данных app1 заполнит буфер pipe и приведёт deadlock
 * ~~адресные пространства не поддерживаются~~

.def[Deadlock] - ожидание системой события, которое гарантировано не наступит.

---
# Пакетный режим

```asciidrawing

         Задача 1     Задача 2    ...
         |            |           |
         +------------+-----------+---------
---------+            |           |         ......->
         +------------+-----------+---------       t
         |
         Включение
```

Можно пытаться извлечь выгоду путем изменения порядка задач.

При условии, что интерфейс/соглашения между ОС и приложениями/пользователями это позволяет.

---
# Невытесняющее планирование

.def[Невытесняющее планирование] - планирование, при котором следующая задача выбирается по завершению предыдущей

.def[Планировщик] - модуль ОС, отвечающий за планирование задач (процессов)

Планировщик:
 * Очередь задач и механизм её поддержания (одно/двусвязный список, куча, ...)
 * Политики определения следущей задачи

---
# Задача

Задача:
 * Окружение ОС (если нужно, например):
  * таблица файловых дескрипторов
  * имя приложения на диске
  * адрес функции входа
  * ...
 * Состояние (может быть представлено неявно):
  * выполняется (первая в очереди)
  * готова для исполнения (находится в очереди, не является первой)
  * выполнена (не в очереди)

Вызовы планировщика:
 * добавить новую задачу
 * текущая задача завершается, удалить её из очереди, запустить новую задачу

---
# Политика

 * FIFO
 * Наименнее короткая сначала:

```
% t10 task1 >t1.out & \
  t20 task2 >t2.out & \
  exit
```
 * Наиболее приоритетная сначала:

```
% p10 task1 >t1.out & \
  p20 task2 >t2.out & \
  exit
```
.def[Приоритет] - абстрактное значение, обозначающее важность для пользователя.

 * С учётом принадлежности пользователю:

```
% Petya: task1 >t1.out & \
  Petya: task2 >t2.out & \
  Vasya: task3 >t3.out & \
  exit
```

---
# Реализация

На Bourne shell
```
$ task1 >t1.out & \
  task2 >t2.out & \
  exit
```

`&` - запустить приложение в фоне

```
	// collect exited background children
	while (0 <  waitpid(-1, NULL, WNOHANG));

	pid_t child = fork();
	if (child == 0) {
		// exec
	}

	if (!amp_suffix) {
		waitpid(child, NULL, 0));
	}
```


---
# Диаграмма состояния

```asciidrawing

         main                  exec
         |                     |
         +--+----------....----+--+---------
---------+  |##########....####|  |#########...>
         +--+----------....----+--+---------   t
            |                     |
            os_sys_read           waitpid

+--+
|  | Время проведённое в выполнении кода приложения
+--+

+--+
|##| Время в коде ядра
+--+
```

---
# В ядре

* Запрос к оборудованию
* Ожидание результата

```
// Активное ожидание
while (!hw_ready()) {
	microsleep();
}
```
```
// Пассивное ожидание
void irq_handler(void) {
	set_hw_ready();
}

set_irq_handler(&irq_handler);
while (!hw_ready()) {
	yield();
}
```

* Выход из системного вызова

---
# Диаграмма состояния

С пассивным ожиданием


```asciidrawing

         main    irq_hnd       exec
         |       |             |
         +--+    |             +--+
---------+  +----+-------------+  +---...>
         +--+    |             +--+      t
            |                  |  |
            os_sys_read  irq_hnd  waitpid

```

---
# Кооперативное планирование

Разбить приложение на набор зависимых задач. Псевдокод:
```
int main() {
	int ret = read(0, buf, sizeof(buf);
	...
}
```
 ---

```

void main() {
	aread(0, buf, sizeof(buf), &readcont);
}

void readcont(int ret, char *buf, size_t size) {
	...
}
```

Пример: `aio(7)`

---
# Реализация

Задача:
 * Состояние
  * ...
  * выполнена (не в очереди)
  * ожидает (не в очереди + бит отличия от "выполнена")

Вызовы планировщика:
 * ...
 * добавить новую ожидающую задачу
 * разбудить задачу ("ожидает" -> "готова")

---
# В ядре

* Запрос к оборудованию
* Установка обработчика прерывания

```
void irq_handler(task) {
	wake(task);
}

add_waiting_task(&task);
set_irq_handler(&irq_handler, &task);
sched_exit();
```

---
# Диаграмма состояния

```asciidrawing

         main                  exec
         |                     |
         +--+                  +--+
---------+  +------------------+  +---...>
         +--+                  +--+      t
            |                  .  |
            os_sys_read        .  waitpid
            .                  .
            main               .
            |                  .
            +------------------+
------------+                  +------...>
            +------------------+         t
                               |
                               os_sys_write


```

---
# Кооперативные политики

* ...
* С принадлежностью задач к процессам
* Приоритет наименьшему времени выполнения
* Динамический приоритет
* Гарантированная

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
