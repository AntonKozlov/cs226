<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

## Безопасность

---
# Литература

* Таненбаум. Современные операционные системы
* Таненбаум. Распределённые системы
* Schneier. Applied Cryptography

---
# Безопасность

Задачи:
* .def[Конфиденциальность] - ограничение получения информации
* .def[Целостность] - контроль изменения информации
* .def[Доступность] - беспрепятственный доступ

Составные части решения:
* Правила доступа (политики)
* Механизмы:
  - .def[авторизация] - проверка возможности выполнения действия
  - .def[аутентификация] - проверка неподдельности
* Реализация механизмов:
  - криптография
* Организационные мероприятия:
  - аудит

---
# Политика

* Модель Белла-Ла Падула (безопасность)

<!--
```asciidrawing
+--------------+R      W+--------------+
| Subject HIGH |<----<]| Object HIGH  |
+--------------+        +--------------+
         ^                     ^
         |                     |
       +-+---------------------+
       | |
       | +---------------------+
       |                       |
+------+-------+R      W+------+-------+
| Subject LOW  |<----<]| Object LOW   |
+--------------+        +--------------+
```
-->

```
┌──────────────┐R      W┌──────────────┐
│ Subject HIGH │<──────>│ Object HIGH  │
└──────────────┘        └──────────────┘
         ^ R                   ^ W
       ┌─┼─────────────────────┘
       │ └─────────────────────┐
┌──────┴───────┐R      W┌──────┴───────┐
│ Subject LOW  │<──────>│ Object LOW   │
└──────────────┘        └──────────────┘
```

* Модель Биба (целостность)

```
┌──────────────┐R      W┌──────────────┐
│ Subject HIGH │<──────>│ Object HIGH  │
└──────────────┘        └──────────────┘
       ┌─┼─────────────────────┘
       │ └─────────────────────┐
       v R                     v W
┌──────────────┐R      W┌──────────────┐
│ Subject LOW  │<──────>│ Object LOW   │
└──────────────┘        └──────────────┘
```

---
# Авторизация

* .def[Избирательная] (благоразумная).
Для объектов определено понятие владельца(/группы).
Субъекты могут передавать права доступа к объектам.
Типы задания:
  - матрица
  - списки контроля доступа (ACL)

* .def[Мандатная] (обязательная).
Объектам и субъектам присваиваются .def[метки] - классификаторы “секретности” информации.
Управление правами доступа осуществляется централизованно администратором.

* .def[Ролевая].
Субъекты имеют множество ролей.
Для каждого объекта определено множество ролей и типов доступа.
Субъекты, объекты и роли управляются централизовано (внутри организации).

* .def[На основе возможностей].
.def[Возможность] (capability) - ссылка на объект с определёнными набором прав.
Две разные возможности могут указывать на один объект с разными правами.
Возможности передаются между программами, составляя иерархии возможностей.

---
# Криптография

Источник хочет переслать сообщение приёмнику так, чтобы сообщение мог прочитать только приёмник.

.def[Шифрование] - процесс изменения сообщения, скрывающий его содержимое.
Дешифрование - обратный процесс.

Задачи криптографии:
* конфиденциальность
* аутентификация
* целостность
* отсутствие отказов (nonrepudiation)

.def[Стеганография] - передать сообщение, скрыв факт передачи:
* Невидимые чернила
* Сокрытия в графических изображениях
* Подделка статистических свойств

???
Статистические свойства:
Peter Wayner’s mimic functions obfuscate messages. These functions modify a message so that its
statistical profile resembles that of something else: the classifieds section of The New York Times, a
play by Shakespeare, or a newsgroup on the Internet [1584,1585]. This type of steganography won’t
fool a person, but it might fool some big computers scanning the Internet for interesting messages.

---
# Алгортимы

.def[Криптографический алгоритм] - математическая функция для шифрования/дешифрования.
* защищённые алгоритмы - безопасность основана на сокрытии алгоритма
* открытые алгоритмы - безопасность основана на сокрытии параметре алгоритма - .def[ключе]

Атаки:
* с шифрованными сообщениями
* с известным сообщением
* с выбранным сообщением
  * адаптивная с выбранным сообщением
* с выбранным шифрованным сообщением
* бандитская

---
# Шифры-подстановки

Каждый символ заменяется на другой
* Простая подстановка
* Несколько шифрованных символов на нешифрованный символ
* Группы символов кодируются вместе: ABA->RTQ; ABB->SLL
* В зависимости от позиции символа применяется один из простых шифров

Пример: XOR
```
a ^ a = 0; a ^ b ^ b = a
```

Взлом XOR:
1. XOR текста с собой со смещением, если кратно длине ключа, то много одинаковых байт
1. XOR текста с собой с найденным смещением, использовать статистические свойства языка

---
# Симметричные алгоритмы

Подстановки, XOR - примеры .def[симметричных] алгоритмов - ключ для дешифрования вычисляется из ключа для шифрования (часто ключи равны).

```
EK(M) = C; DK(C) = M
```

* Потоковые алгоритмы: работают на каждом бите (или байте)
* Блочные: на каждом наборе из бит - блоке

.def[Одноразовые блокноты] - симметричный алгортм с бесконечным ключом - последовательностю случайных символов.
При шифровании данных длины L, в качестве ключа используется префикс последовательности длины L.
После однократнго кодирования префикс больше не исиспользуется.

Не содержит статистических регулярностей языка, поэтому стоек.

Но нужна _случайная_ последовательность символов.

---
# Протокол

Последовательность шагов для двух или более сторон, направленных на выполнение задачи. Требования:
* стороны должны знать протокол
* выполнять его
* протокол должен быть однозначен
* должен охватывать все возможные ситуации

.def[Криптографический протокол] - невозможно совершить действие или получить информацию, кроме ситуаций, явно разрешённых протоколом
* с арбитром (arbitrated)
* с вспомогательным центром (adjudicated)
* самореализующийся (self-enforcing)

---
# В симметричной системе

Протокол обмена в симметричной криптосистеме:

1. Alice и Bob договариваются о
  - алгоритмах
  - ключах
1. Alice шифрует сообщение
1. Alice отправляет шифровку Bob
1. Bob расшифровывает сообщение

Проблемы:
* Ключи должны распространяться секретно
* Если ключ скомпрометирован, можно читать чужие сообщения и внедрять ложные
* Для каждой пары пользователей требуется ключ, количество O(n2)

---
# Односторонние функции

```
f(x) = y; g(y) = x;
```
f - легко; g - сложно

Пример: односторонний хеш (MDn, SHA-n) - принимает вход произвольной длины, возвращает строку фиксированной длины.

Хороший хеш обладает низком числом коллизий: сложно сгенерировать два входа с одинаковым хешом

На основе односторонних функций строятся ассиметричные алгоритмы (1976: Diffie, Hellman)

K1 - открытый ключ; K2 - закрытый ключ

Закрытый ключ не может быть вычислен из открытого (за разумное время)

EK1(M) = C; DK2(C) = M

Пример: RSA

---
# В асимметричной системе

Протокол обмена в асимметричной криптосистеме:

1. Alice и Bob договариваются о алгоритмах
1. Bob отправляет свой открытый ключ
1. Alice шифрует им сообщение и отправляет его Bob
1. Bob расшифровывает сообщение используя свой закрытый ключ

Проблемы:
* Ассиметричные алгоритмы медленные
* Уязвимы к атакам с выбранными сообщениям

???

Public-key cryptosystems are vulnerable to chosen-plaintext attacks. If C = E(P), when P is
one plaintext out of a set of n possible plaintexts, then a cryptanalyst only has to encrypt all n
possible plaintexts and compare the results with C (remember, the encryption key is public).
He won’t be able to recover the decryption key this way, but he will be able to determine P.

---
# Гибридные криптосистемы

Сессионные ключи для симметричного шифрования, которые выбираются с помощью асимметричного:
1. Bob отправляет свой открытый ключ
1. Alice генерирует сессионный ключ, шифрует его открытым ключом Bob
1. Bob расшифровывает сессионный ключ используя свой закрытый ключ
1. Используется симметричное шифрование с сессионным ключом

Алгортим Diffie-Hellman
Alice и Bob несекретно выбирают простое n и его первообразный корень g
1. Alice выбирает случайно число x, высылает X = gx mod n
1. Bob выбирает случайно число y, высылает Y = gy mod n
1. Alice вычисляет k = Yx mod n = gxy mod n
1. Bob вычисляет k = Xy mod n = gxy mod n

---
# Атака Man-in-the-Middle

Предположим, существует Mallory - субъект, способный
видеть,
блокировать/менять/высылать новые сообщения.
Обмен ключами в ассиметричной системе:

1. Alice отправляет свой открытый ключ
1. Bob отправляет свой открытый ключ
1. Alice генерирует сессионный ключ, шифрует его открытым ключом Bob
1. Bob расшифровывает сессионный ключ используя свой закрытый ключ
1. Используется симметричное шифрование с сессионным ключом

Атака:
--

1. Mallory перехватывает открытый ключ Alice и отправляет Bob свой
1. Mallory перехватывает открытый ключ Bob и отправляет Alice свой
1. Mallory расшифровывает отправленное Alice и шифрует его собственным ключом
1. Mallory расшифровывает отправленное Bob и шифрует его собственным ключом

Решение:
--

алгоритм Interlock
1. Alice шифрует открытым ключом Bob, отправляет половину
1. Bob шифрует открытым ключом Alice, отправляет половину
1. Alice отправляет вторую половину
1. Bob расшифровывает, отправляет вторую половину
1. Alice расшифровывает сообщение

???

He
can still substitute his own public keys for Alice’s and Bob’s in steps (1) and (2). But now, when he
intercepts half of Alice’s message in step (3), he cannot decrypt it with his private key and re-encrypt
it with Bob’s public key. He must invent a totally new message and send half of it to Bob. When he
intercepts half of Bob’s message to Alice in step (4), he has the same problem. He cannot decrypt it
with his private key and re-encrypt it with Alice’s public key. He has to invent a totally new message
and send half of it to Alice. By the time he intercepts the second halves of the real messages in steps
(5) and (6), it is too late for him to change the new messages he invented. The conversation between
Alice and Bob will necessarily be completely different.


---
# Цифровая подпись

* подлинность: сообщение подписано
* неподдельность: подписано именно им
* не переиспользуется
* документ не менялся после подписания
* не может отрицаться

Пример: подпись с симметричным алгоритмом и арбитром.
Между каждым пользователем и арбитром установлен секретный ключ.

1. Alice шифрует сообщение и посылает арбитру
1. Арбитр дешифрует, шифрует с информацией “источник - Alice”, посылает Bob
1. Bob дешифрует сообщение и подпись

???
1. This signature is authentic. Trent is a trusted arbitrator and Trent knows that the message
came from Alice. Trent’s certification serves as proof to Bob.

2. This signature is unforgeable. Only Alice (and Trent, but everyone trusts him) knows K A ,
so only Alice could have sent Trent a message encrypted with K A . If someone tried to
impersonate Alice, Trent would have immediately realized this in step (2) and would not
certify its authenticity.

3. This signature is not reusable. If Bob tried to take Trent’s certification and attach it to
another message, Alice would cry foul. An arbitrator (it could be Trent or it could be a
completely different arbitrator with access to the same information) would ask Bob to produce
both the message and Alice’s encrypted message. The arbitrator would then encrypt the
message with K A and see that it did not match the encrypted message that Bob gave him. Bob,
of course, could not produce an encrypted message that matches because he does not know
K A .

4. The signed document is unalterable. Were Bob to try to alter the document after receipt,
Trent could prove foul play in exactly the same manner just described.

5. The signature cannot be repudiated. Even if Alice later claims that she never sent the
message, Trent’s certification says otherwise. Remember, Trent is trusted by everyone; what
he says is true.

---
# Подпись с асимметричным алгоритмом

1. Alice шифрует документ своим закрытым ключом (подпись)
1. Alice посылает подписанный документ
1. Bob дешифрует сообщение открытым ключом Alice

Но скрывать само сообщение не требуется, модификация с хешом:
1. Alice подсчитывает хеш документа
1. Alice шифрует хеш её закрытым ключом (подпись)
1. Alice посылает документ и подписанный хеш
1. Bob подсчитывает хеш и дешифрует хеш с Alice. Подпись верна, если хеши равны

???
1. The signature is authentic; when Bob verifies the message with Alice’s public key, he
knows that she signed it.

2. The signature is unforgeable; only Alice knows her private key.

3. The signature is not reusable; the signature is a function of the document and cannot be
transferred to any other document.

4. The signed document is unalterable; if there is any alteration to the document, the signature
can no longer be verified with Alice’s public key.

5. The signature cannot be repudiated. Bob doesn’t need Alice’s help to verify her signature.








    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
