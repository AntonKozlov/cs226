<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Распределенные системы

---
# Литература

* Таненбаум. Распределённые системы
* Attiya, Welch. Distributed Computing: Fundamentals, Simulations and Advanced Topics
* Coulouris, Dollimore, Kindberg, Blair. Distributed Systems: Concepts and Design
* Lynch. Distributed Algorithms

---
# Распределённые системы

.def[Распределённая система] - набор вычислительных устройств, взаимодейстующих друг с другом.

Мультикомпютер - вычислитель, построенный из специальных узлов, соединенных высокопроизводительной сетью.

Распределенная система - множество устройств, соединенных обычной сетью

Фундаментальные проблемы:
 * Асинхронность
 * Ограниченное локальное знание
 * Отказы

Технические проблемы:
 * Гетерогенные ПО и АО


???
Таненбаум:

Мультикомпютер:
 * общая ФС
 * узел не имеет/имеет мало переферии

Распределенная система:
 * собственные ФС
 * полноценный компьютер


---
# Cильносвязанная

.def[Cильносвязанная система] (.def[Распределенная ОС]) - набор служб представляет распределенную систему как единую вычислительную.

.left[
```
┌────────┐ ┌────────┐ ┌────────┐
│┌───────┴─┴────────┴─┴───────┐│
││         Приложения         ││
│└───────┬─┬────────┬─┬───────┘│
│┌───────┴─┴────────┴─┴───────┐│
││  Службы распрeделенной ОС  ││
│└───────┬─┬────────┬─┬───────┘│
│┌──────┐│ │┌──────┐│ │┌──────┐│
││ Ядро ││ ││ Ядро ││ ││ Ядро ││
│└──────┘│ │└──────┘│ │└──────┘│
└────┬───┘ └────┬───┘ └────┬───┘
     │          │          │
─────┴──────────┴──────────┴────
```
]

Примеры:
 * Plan 9
 * Распределенные ФС, NFS

---
# Слабосвязанная

.def[Слабосвязанная система] - разные ОС, объединённые набором сервисов (.def[middleware])

.left[
```
┌────────┐ ┌────────┐ ┌────────┐
│┌───────┴─┴────────┴─┴───────┐│
││         Приложеня          ││
│└───────┬─┬────────┬─┬───────┘│
│┌───────┴─┴────────┴─┴───────┐│
││Службы промежуточного уровня││
│└───────┬─┬────────┬─┬───────┘│
│┌──────┐│ │┌──────┐│ │┌──────┐│
││Службы││ ││Службы││ ││Службы││
││  OC  ││ ││  OC  ││ ││  OC  ││
│└──────┘│ │└──────┘│ │└──────┘│
│┌──────┐│ │┌──────┐│ │┌──────┐│
││ Ядро ││ ││ Ядро ││ ││ Ядро ││
│└──────┘│ │└──────┘│ │└──────┘│
└────┬───┘ └────┬───┘ └────┬───┘
     │          │          │
─────┴──────────┴──────────┴────
```
]

Примеры:
 * WWW

---
# Асинхронность

.def[Асинхронные системы]
 * сообщения доставляются независимо
 * нет верхней границы времени доставки

```
Узел 1
─────┼───┼───┼──────────┼──────────┼─────

───────┼──────┼─────┼────────┼──────┼────
Узел 2
```

.def[Синхронные системы] - определяется .def[раунды обмена сообщениями]
 * обмен сообщениями только в течении раунда
 * доставляются все сообщения
 * вычисления опираются на данные прошедшего раунда

```asciidrawing
Узел 1
----++--------++--------++-------++------
    ||        ||        ||       ||
----++--------++--------++-------++------
Узел 2
```
Полностью не реализуется на практике, но является хорошей моделью для разработки алгоритмов.

---
Построение остовного дерева с известным корнем
```
code for processor p[i], 0 < i < n — 1.

parent = 0, children = {}, and other = {}.

upon receiving no message:
        if p[i] = p[r] and parent = 0 then // root has not yet sent ("M")
        send ("M") to all neighbors
        parent := p[i]

upon receiving ("M") from neighbor p[j]:
        if parent = 0 then // p[i] has not received ("M") before
                parent := p[j]
                send ("parent") to p[j]
                send ("M") to all neighbors except p[j]
        else send ("already") to p[j]

upon receiving ("parent") from neighbor p[j]:
        add p[j] to children
        if children and other contains all neighbors except parent then
                terminate

upon receiving ("already") from neighbor p[j]:
        add p[j] to other
        if children and other contains all neighbors except parent then
                terminate
```
---
Замечание: BFS - только в синхронной сети

```
p0 --> p1
 |    /
 |   /
 v  v
  p2
```

---
# Взаимное исключение

* Централизованный алгоритм
* Децентрализованный:
  * если получатель в крит. секции, сообщение помещается в буфер
  * если получатель вне крит. секции, высылается разрешение
  * если получатель в процессе входа в крит. секцию, входит тот, у кого время начала входа минимально

---
Построение остновного дерева без выделенного корня, DFS

```
parent = NULL, leader = —1, children = {}, unexplored = all neighbors of p;
upon receiving no message:
        if parent = NULL then // wake up spontaneously
                leader := id; parent := pt; explore()

upon receiving ("leader",new-id) from p[j]:
        if leader < new-id then // switch to new tree
                leader := new-id; parent := p[j]; children := 0
                unexplored := all neighbors of p[i] except p[j]
                explore()
        else if leader = new-id then
                send ("already",leader) to p[j] // already in same tree
        // otherwise, leader > new-id and the DFS for new-id is stalled

upon receiving ("already",new-id) from p[j]:
        if new-id = leader then explore()

upon receiving ("parent",new-id) from p[j]:
        if new-id = leader then //otherwise ignore message
                add p[j] to children; explore()

procedure explore():
        if unexplored != {} then
                p[k] := a processor in unexplored
                remove p[k] from unexplored
                send ("leader",leader) to p[k]
        else
                if parent != p[i] then send ("parent",leader) to parent
                else terminate as root of spanning tree
```
---
# Лидер

Алгоритм для построения остовного дерева без выделенного корня для каждого узла пытается построить остовное дерево с корнем в этом узле.
Затем все узлы выбирают одно дерево в качестве ответа.

Этот алгоритм является .def[nonuniform] - зависит от числа узлов в системе.

Алгоритм является частным решением задачи определения .def[лидера] - выделенного узла среди изначально равноправных узлов.
---
# Лидер в кольце

(Здесь должен быть алгоритм)



---
# Синхронизация времени

NTP: протокол синхронизации времени
 * перевод времени вперёд/назад: замедление и ускорение
 * корректировка ответного сообщения: (время приёма - время отправки)/2

Логическое время:
 * a < b, если происходят в одном процессе
 * отправка сообщения < приёма сообщения

Алгоритм Лампорта:
 * узел увеличивает своё время при каждом событии, в т. ч. передаче сообщения
 * к кажому сообщению прилагается отметка времени при посылке
 * при приеме сообщения узел устанавливает время больше, чем отметка в сообщении

---
# Алгоритм Лампорта
```asciidrawing

+--+         +--+         +--+        +--+         +--+         +--+
| 0|         | 0|         | 0|        | 0|         | 0|         | 0|
+--+         +--+         +--+        +--+         +--+         +--+
| 4+----+    | 6|         | 8|        | 4+----+    | 6|         | 8|
+--+    |    +--+         +--+        +--+    |    +--+         +--+
| 8|    +--->|12|         |16|        | 8|    +--->|12|         |16|
+--+         +--+         +--+        +--+         +--+         +--+
|12|         |18+----+    |24|        |12|         |18+----+    |24|
+--+         +--+    |    +--+        +--+         +--+    |    +--+
|16|         |24|    +--->|32|        |16|         |24|    +--->|32|
+--+         +--+         +--+        +--+         +--+         +--+
|20|         |30|         |40|        |20|         |30|         |40|
+--+         +--+         +--+        +--+         +--+         +--+
|24|         |36|    +----+48|        |24|         |36|    +----+48|
+--+         +--+    |    +--+        +--+         +--+    |    +--+
|28|         |42|<---+    |56|        |28|         |49|<---+    |56|
+--+         +--+         +--+        +--+         +--+         +--+
|32|    +----+48|         |64|        |32|    +----+55|         |64|
+--+    |    +--+         +--+        +--+    |    +--+         +--+
|36|<---+    |54|         |72|        |56|<---+    |61|         |72|
+--+         +--+         +--+        +--+         +--+         +--+
|40|         |60|         |80|        |59|         |67|         |80|
+--+         +--+         +--+        +--+         +--+         +--+
```

---
# Векторные часы

Часы Лампорта "стирают" информацию о независимости событий

```asciidrawing
        1    2
        1    1
        0    0
--------o----o---------------------------
       /      \
   0  /   0    \                  2
   1 /    2     \                 3
   0/     0      \                3
---o------o-------\---------------o------
                   \             /
            0       \  2     2  /
            0        \ 1     1 /
            1         \2     3/
------------o----------o-----o-----------
```

Решение - векторные часы:
 * время представляется вектором длины N (количество узлов в системе)
 * каждый узел поддерживает копию вектора времени
 * при внутренних событиях собственный компонент времени увеличивается
 * при отправке прикрепляется целый вектор
 * при приеме локальная копия вектора обновляется покомпонентным максимумом

F. Mattern. Virtual Time and Global States of Distributed Systems


---
# Отказы

Типы:
* .def[Авария] (crash) - узел выходит из строя. Часть сообщений доставляется.
* .def[Византийский отказ] - узел работает некорректно: могут исказиться ввод, локальное состояние, вывод

В такой модели узлы должны действовать согласовано.
Формально, достигать .def[консенсуса] - общего решения со свойствами:
* Конечность (Termination): каждый несбойный узел имеет своё решение
* Согласованность (Agreement): решения всех несбойный узлов совпадают
* Обоснованность (Validity): если все узлы предлагают одно значение, несбойные узлы должны согласиться на значение.

---
# Консенсус при авариях

Асинхронные системы: не существует алгоритмов консенсуса (в полностью асинхронных системах).

Синхронные системы: n процессов, f подвержен отаказам.

```
V = {x} // V contains pi input

round k, 1 <= k <= f + 1:
        send {v from V : pi has not already sent v} to all processors
        receive Sj from pj, 0 <= j <= n - 1, j != i
        V := V + { Sj : 0 <= j <= n - 1}
        if k = f + 1 then y := min(V) // decide
```
Любой алгоритм консенсуса для n (n > f + 2) процессов требует не менее f + 1 раундов, т.е. алгоритм оптимален.

---
# Консенсус при византийских отказах

Не существует алгоритма консенсуса при n <= 3f

Существует алгоритм с f + 1 раундами, при 3f + 1 <= n

---
# Отказоустойчивость

.def[Отказоустойчивость] - способность системы продолжать выполнять свою функцию при наличие отказов

Реализуется маскированием ошибок с помощью избыточности
 * пространственной (код Хемминга,...)
 * временной (TCP, ...)
 * физической (резервные системы, ...)

.def[Транзакция] - группа операций, происходящих атомарно. Свойства:
* Atomicity
* Consistency
* Isolation
* Durability

Интерфейс транзакций:
```
BEGIN
        modify
        modify
        COMMIT/ABORT
END
```
---
# Реализация

Возможноые реализации транзакций на одном узле

.def[Закрытое рабочее пространство].
Транзакции выполняются в отдельном пространстве.
Данные копируются COW.
При успешном применении данные записываются в основное пространство.
При неудаче закрытое пространство удаляется.

.def[Журнал с упреждающей записью].
Каждое изменение предваряется записью в журнал, затем изменение применяется.
Если транзакция успешна, то записи в журнале помечаются как применённые (журнал очищается)
В противном случае, изменения, описанные в журнале, отменяются начиная с самых новых в обратном порядке до последних применённых.

---
# .fsmall[Транзакции в распределённой системе]

* .def[Вложенная транзакция] - состоит из независимых транзакций в дочерних независимых между собой системах
* .def[Распределённая транзакция] - состоит из дочерних транзакций к различным физическим частям единой распределённой системы.

Физические части могут иметь пересечение - .def[репликацию] данных для увеличения производительности, повышения надёжности

.def[Распределённое подтверждение] - реализация распределенной транзакции

2 Phase Commit:
1. Координатор рассылает всем VOTE_REQUEST
2. Участники отвечают VOTE_ABORT либо VOTE_COMMIT
3. Если все ответы VOTE_COMMIT, координатор выслыает всем GLOBAL_COMMIT; иначе - GLOBAL_ABORT
4. Участники получают GLOBAL_COMMIT, тогда транзакция применяется локально; GLOBAL_ABORT - отменяется

Участник(и) и координатор могут выйти из строя в любой момент.
 * timeout для определения вышедшего из строя узла
 * общение между узлами на время недоступности координатора

---
# Восстановление

.def[Восстановление] - переход в корректное состояние после ошибки

Типы восстановления:
 * обратное
 * прямое

Контрольные точки:
 * независимые
 * координированные

Протоколирование сообщений может использоваться для снижения накладных расходов на создание контрольных точек





</textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
