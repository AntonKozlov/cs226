<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="slides.css">
    <script src="remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Сетевое программирование

---
# Литература

* Таненбаум, Современные ОС, 8.4
* Таненбаум, Компьютерные сети

---
* 1950: телефонная сеть
![](chan_vs_packet.png)

---
* 1969: ARPANET
![](arpanet.png)

* 1976: TCP/IP как протокол передачи, не зависящий от сети (ARPANET, спутниковая связь, ...). Позже: Berkeley сокеты

* 1984: NSFNET с выходом в ARPANET

* Internet

---
.def[Коммутация] - способ взаимодействия между узлами:
* .def[Канальная] - для узлов резервируется линия связи - .def[канал] (телефонная сеть)
* .def[Пакетная] - узел передает множество пакетов информации (компьютерные сети)

Тип передачи:
* Направленная - один источник, один приемник
* Широковещательная - один источник, множество приемников

Размеры сетей:
* Персональные (Personal Area Network)
* Локальные (Local Area Network)
* Муниципальные (Metropolitan Area Network)
* Глобальные (Wide Area Network)

```asciidrawing
+-+ +-+                              +-+ +-+
+++ +++                              +++ +++
 |   |   +-+           +-+      +-+   |   |
 +---+---+M+-+---------+M|   +--+M+---+---+
         +-+ |         +++   |  +-+
             | +-+      |    |       +-+ +-+
+-+ +-+      +-+M+------+----+       +++ +++
+++ +++      | +-+      |       +-+   |   |
 |   |   +-+ |          +-------+M+---+---+
 +---+---+M+-+----------+       +-+
         +-+
```

---

![](arpanet.png)

```asciidrawing
+-------------------+                  +-------------------+
| Протокол уровня 3 +- - - - - - - - ->| Протокол уровня 3 |
+-------------------+                  +-------------------+
          v                                      ^
+-------------------+                  +-------------------+
| Протокол уровня 2 |- - - - - - - - ->| Протокол уровня 2 |
+-------------------+                  +-------------------+
          v                                      ^
+-------------------+                  +-------------------+
| Протокол уровня 1 +----------------->| Протокол уровня 1 |
+-------------------+                  +-------------------+
```
---
# Свойства протоколов

```asciidrawing
+-----+     +-----+                    +-----+
|Хост1| ... |ХостN|  - - - - - - - - ->|ХостM| ...
+-----+     +-----+                    +-----+
               v                          ^
+-------------------+                  +-------------------+
|  Маршрутизатор 1  |----------------->|  Маршрутизатор 2  |
+-------------------+                  +-------------------+
```

* Адресация
* Логические каналы, перенос данных между уровнями и (де)мультиплексирование
* Контроль ошибок

---
# Стек OSI
<ol reversed>
<li>Прикладной: приложения: http, ftp</li>
<li>Представления: преобразование представление данных</li>
<li>Сеансовый: поддержание сеансов связи</li>
<li>Транспортный: надёжная передача данных: TCP, UDP, ...</li>
<li>Сетевой: определение пути передачи: IP, ...</li>
<li>Канальный: определение границ кадров и контроль доступа: Ethernet, PPP, ...</li>
<li>Физический: передача битов</li>
</ol>

---
# Стек TCP/IP

<ol reversed>
<li>Прикладной: приложения</li>
<li>Транспортный: надёжная передача данных. Только TCP, UDP</li>
<li>Интернет: передача от хоста к хосту</li>
<li>Канальный: доставка IP пакетов от хоста в сеть</li>
</ol>

---
# Канальный уровень
Передача:
* данные делятся на кадры
* каждый кадр дополнятся контрольной суммой
Приём:
* из потока битов формируются кадры
* для каждого проверяется контрольная сумма

Хосты работают независимо, но обладают единым каналом передачи данных. Если 2 кадра пересекаются во времени, оба искажаются - .def[коллизия].

Для решения используется .def[контроль доступа к среде] - алгоритм определения возможности передачи.
Зависит от модели времени: дискретное/непрерывное; наличия контроля несущей: есть/нет.

Пример: Ethernet
* Двоичный экспоненциальный откат
* Время передачи минимального сообщения > 2*времени прохождения кадра (время распространения сигнала)

---
# Сетевой уровень

```asciidrawing
 +-+           +-+      +-+
-+M+-+---------+M|   +--+M+-
 +-+ |         +++   |  +-+
     | +-+      |    |
     +-+M+------+----+
     | +-+      |       +-+
 +-+ |          +-------+M+-
-+M+-+----------+       +-+
 +-+
```

* Единая адресация
* Независимость от топологии сети
* Пакетная/канальная коммутация

Интернет протоколы:
* Передача данных: IP
 * фрагментация
* Управляющий: ICMP
* Разрешение адресов: ARP

---
# Транспортный уровень

Типы
* Без соединения, без подтверждения: UDP
* Без соединения, с подтверждением
* С соединением и подтверждением: TCP

.def[Порт] - идентификатор сетевого ресурса на узле

---
# TCP

.left[
```
Host1                           Host2
┌─┐                               ┌─┐
│ │                               │ │
│ │          SYN(SEQ = x)         │ │
│ ├──────────────────────────────>│ │
│ │                               │ │
│ │   SYN(SEQ = y, ACK = x + 1)   │ │
│ │<──────────────────────────────┤ │
│ │                               │ │
│ │ SYN(SEQ = x + 1, ACK = y + 1) │ │
│ ├──────────────────────────────>│ │
│ │                               │ │

    Пример: установление соединения
```
]

Свойства:
* обработка ошибок
* в правильном порядке
* без повторов
* управление потоком

В каждом сообщении:
* номер сегмента
* размер буфера

На каждое принятое сообщение - сообщение об успешном приёме и, возможно, данные (полнодуплексный протокол).
Сообщение перепосылается, если нет подтверждения в течение некоторого времени.

---
# Berkeley сокеты

Сокет - _канальный_ интерфейс работы с сетевым стеком

Общая инициализация:
* `int socket(int domain, int type, int protocol);` - создать сокет
* `int bind(int socket, const struct sockaddr *address, socklen_t address_len);` - установить локальный адрес сокета

Инициализация для клиента:
* `int connect(int socket, const struct sockaddr *address, socklen_t address_len);` - подключиться к серверу

Обычная работа:
* `read` или `ssize_t recvmsg(int socket, struct msghdr *message, int flags);` - получить сообщение
* `write` или `ssize_t sendmsg(int socket, const struct msghdr *message, int flags);` - послать сообщение

Деинициализация:
* `close` - закрыть сокет, в зависимости от типа, возможно, послать все отложенные исходящие сообщения

---

Инициализация для сервера:
* `int listen(int socket, int backlog);` - начать принимать подключения
* `int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len);` -
принять ожидающее подключение. Возвращает _ещё один_ сокет, соответсвующий новому соединению.
Изначальный сокет продолжает принимать подключения.

Для TCP/UDP:
* Для мультиплексирования, каждый сокет должен соответствовать порту протокола транспортного уровня.
* Но на один серверный порт может приходиться множество подключений. Полный идентификатор канала на узле состоит из:
 1. Локального адреса/идентификатора сетевого устройства
 1. Локального порта
 1. Удаленного адреса
 1. Удаленного порта

Ссылки:
1. Стивенс, "UNIX. Разработка сетевых приложений"
1. http://berb.github.io/diploma-thesis/original/042_serverarch.html

---
# HTTP

Протокол HTTP реализуется на TCP. Cхема протокола:

```
<method> <target> HTTP/1.1\r\n
<option>*\r\n
\r\n
<data>
```
Производительный http сервер должен быть способен обрабатывать множество существующих подключений и приём новых паралелльно.

Варианты реализации:
* Многопроцессная - новый экземпляр сервера на каждое соединение (fork)
* Многопоточная - отдельный поток сервера на каждое соединение
* Событийная:
 * Reactor - синхронно диспетчеризует запросы обработчикам
 * Proactor - асинхронный reactor



    </textarea>
    <script src="slides.js" type="text/javascript"></script>
  </body>
</html>
