<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Виртуальная память

---
# Виртуальная память

.def[Виртуальная память] - принцип позволяющий использовать больше оперативной памяти, чем есть на машине.

Памяти может быть меньше чем необходимо для размещения всех процессов.

Сегментная модель памяти - адресное пространство состоит из набора сегментов.

```asciidrawing
       Процесс 1     Процесс 2
    +-----+-------+-----+-------+
RAM |.text|  ...  |.text|  ...  |
    +-----+-------+-----+-------+
```

.def[Swapping] - сбросить адресное пространство памяти процесса на диск.

Сегменты вытесняются целиком.

---
# Страничная модель

Страничная модель память - адресное пространство состоит из набора страниц.

```asciidrawing
Логическое пространство
+---+---+---+---+---+
|   |   |   |   |   |
+-+-+---+-+-+-+-+---+
  |       |   |
  +---+---+   +---+
+---+-v-+---+---+-v-+
|   |   |   |   |   |
+---+---+---+---+---+
Физическое пространство
```

Позволяет размещать часть памяти процесса (подмножество страниц) на диске - .def[paging].

Некоторые страницы виртуальной памяти могут быть отображением в "запрещённые" области физической памяти или быть неотображенными.

---
# Программная реализация

Не нужно отображать каждый адрес, достаточно только страницы.

Например: таблица - для каждой виртуальной страницы - физическую странцу.

.left[
```asciidrawing
         N            P        0
 Virtual +------------+--------+
    addr |    idx     | offset |
         +------------+--------+

  0   1   2   3   4
+---+---+---+---+---+
| 0 |   | 1 | 1 |   |
+-+-+---+-+-+-+-+---+
  |   +---+---+
+-v-+-v-+
|   |   |
+---+---+
  0   1

Physical +------------+--------+
    addr |    base    | offset |
         +------------+--------+
         N            P        0
```
]

Реализация: на каждое обращение памяти генерировать исключение:
 * вычислить номер виртуальной страницы (`адрес обращения >> разер страницы`)
 * по таблице определить номер физической страницы
 * вычислить физический адрес (`адрес физ страницы | offset`)

---
# Аппаратный кеш

Генерировать исключение на каждое обращение к памяти дорого.

Отображение aппаратно ускоряется с помощью модуля процессора Memory Management Unit (MMU).

Возможная реализация - кеш:
 * (аппаратура) на каждое обращение к памяти получить номер/адрес странциы
 * (аппаратура) проверить кеш, если отображение не закешировано, сгенерировать исключение
 * обработчик добавляет новое значение в кеш, перезапускает инструкцию

Устройство кеша (например):
 * список пар: виртуальный/физический адрес страниц и тип доступа
 * аппаратная проверка кеша: проверить каждый виртуальный адрес из списка, при совпадении использовать физический адрес
 * обращения в память - долгая операция, кеш располагается в процессоре
 * _изменение_ записи в кеше - сброс и заполнение кеша заново

<!--
 Например, кеш для 32-битной машины и страниц размера `4096 == 2^12` байт
```asciidrawing
     43     24 23      4  3   2   1   0
    +---------+---------+---+---+---+---+
  N | phyaddr | viraddr | R | W | X | E |
    +---------+---------+---+---+---+---+
R/W/X - разрешение на чтение/запись/исполнение
E - другие поля определены
```
-->
---

.left[
```asciidrawing
P - размер страницы

         N            P        0
 Virtual +------------+--------+
    addr |    idx     | offset |
         +------------+--------+

   +----------+
  0|  record  |
   +----------+
  1|  record  |
   +----------+
  .|  record  |
  .+----------+
  .|  record  |
   +------+---+
idx| base | f |
   +------+---+
   |  record  |
   +----------+

Physical +------------+--------+
    addr |    base    | offset |
         +------------+--------+
         N            P        0
```
]

MMU может самостоятельно выполнять логику отображения по таблице (слева).

Теперь, ПО не контролируем момент обращения, запись может нести дополнительную информацию:

```asciidrawing
+---------+---+---+---+---+---+---+
| phyaddr | R | W | X | M | A | E |
+---------+---+---+---+---+---+---+
```
* R/W/X - разрешение на чтение/запись/исполнение
* M - был ли доступ на запись
* A - был ли доступ на чтение
* E - другие поля записи определены

---

Таблица очень большая, например, для 32 битной архитектуры

```
4б [запись] * (4Гб [пространство] / 4Kб [страница]) = 4Мб [таблица]
```

.left[
```asciidrawing
         N             P        0
 Virtual +------+------+--------+
    addr | idx1 | idx2 | offset |
         +------+------+--------+
                           t2 base
    +-------------+  +---->+-------------+
    |    record   |  |     |    record   |
    +-------------+  |     +---------+---+
    |    record   |  | idx2|   base  | f |
    +-------------+  |     +---------+---+
    |    record   |  |     |    record   |
    +---------+---+  |     +-------------+
idx1| t2 base | F +--+
    +---------+---+
    |    record   |
    +-------------+

Physical +-------------+--------+
    addr |     base    | offset |
         +-------------+--------+
         N             P        0
```
]

Большая часть страниц не отображена. Решение - многоуровневая таблица.

Просмотр многоуровненвых таблиц плохо сказывается на производительности.
Для ускорения вводят .def[Translation Lookaside Buffer] (TLB) - кеш отображений.

TLB - кеш: требуется инвалидация при обновлении таблиц.


---
# Paging

При обращении по неотображенному участку виртуальной памяти происходит исключение.

Реализация paging:
1. В начальный момент времени все страницы находятся в памяти
2. При запросе дополнительной памяти, который не может быть удовлетворён, ядро:
 * ищет страницу-жертву, которая будет вытеснена на диск
 * ищет адрес на диске для сохранения данных страницы
 * по завершению вытеснения, помечает страницу неотображенной для MMU, сохраняет адрес на диске
3. В течение работы может произойти обращение к вытесненной странице,
 * происходит исключение (страница не отображена)
 * ядро удостоверяется, что запрос произведён к вытесненной странице
 * определяется новая странца-жертва, которая вытесняется
 * на место жертвы c диска загружается целевая странца
 * устанавливается отображение
 * ядро выходит из исключения с повтором инструкции

---
# Выбор жертвы

.left[
```asciidrawing cut
X
.     Процесс 1
.+---+---+---+---+---+
.|   |   |   |   |   |
.+-+-+---+---+-+-+---+
.  |       +---+
.+-v-+---+-v-+
.|   |   |   |
.+---+-^-+---+
.  +---+
X  |       |   |
.+-+-+---+-+-+-+-+---+
.|   |   |   |   |   |
.+---+---+---+---+---+
.     Процесс 2
```
]

Выбор страницы-жертвы существенно влияет на производительность.

Выбор зависит от:
 * порядка планирования процессов
 * последовательности обращения самих процессов

.def[Пробуксовка] - ситуация, когда система находится в постоянной выгрузке/загрузке страниц, выполняя небольшое количество инструкций программ (полезной работы).

.clear[
Известны хорошие, но непрактичные алгоритмы:
* Belady's MIN: вытеснять страницы, которые будут использоваться как можно позже
  * не знаем будущее
* Least Frequently Used (LFU): вытеснять страницы, которые использовались нечасто
  * подсчитывать частоту использования дорого
]

---
# Алгоритмы выбора жертвы

## First In First Out (FIFO)
 * поддерживать список страниц, упорядоченный по времени загрузки, от самой старой страницы
 * вытеснять первую (самую старую) страницу

Вытесняет потенциально используемые страницы.

## Второй шанс (Second chance)
 * список страниц как FIFO
 * если бит Access первой страницы установлен, перенести её в конец списка, перейти к следующей

Вырождается в предыдущий алгоритм, если A установлен у всех страниц.

## Часы (Clock)
 * Второй шанс, но над кольцом вместо списка
 * перенести в конец == перейти к следующему элементу в кольце

Техническая оптимизация Второго шанса.

---
# Алгоритмы выбора жертвы

## Least Recently Used (LRU)
 * вытеснять страницу, которая использовалась наиболее давно
 * в чистом виде учитывать время трудно: нужно уметь упорядочивать отображения по времени последнего использования.
   * аппаратура может сохрянять время (в абстрактных единицах) при каждом обращении.

## Not Recently Used (NRU)
 * кольцо или список
 * периодически сбрасывать флаг A
 * при необходимости вытеснения выбрать страницу со сброшенным A
 * модификация: учитывать M, вытеснить первую из упорядочения по классам (биты A/M): 0/0, 0/1, 1/0, 1/1

---
# Алгоритмы выбора жертвы

## Not Frequently Used (NFU)
 * поддерживать счётчик обращений (аппаратно/периодически сбрасывать A, запоминая значение)
 * .def[старение] счётчика - уменьшение значения со временем
   * `C = C >> 1 & (A << 31)`

## Уменьшение набора сканирования страниц
 * поддерживать два класса страниц
   * active: в памяти, есть отображения на неё
   * inactive: в памяти, нет отображения
 * вытеснять страницы из inactive
 * переносить страницы из active в inactive
   * по статистике использования (NRU, NFU, ...)
   * по целевой эвристической функции
 * ошибочное перенесение в inactive быстро исправляется (страница ещё в памяти)

---
# Алгоритмы выбора жертвы

## Рабочий набор
 * w(k,t) - набор из страниц, к которым процесс получил доступ последние k обращений к памяти за последние t времени. Можно рассматривать w(inf, const)
 * вытеснять не попадающие в рабочий набор
   * снова нужно считать возраст страницы, теперь в .def[виртуальном] времени, которое процесс занимает процессор.
 * загружать не по одной странице по исключению, а рабочий набор или его часть

## WSClock:
 * рабочий набор + часы
 * http://www.cs.nyu.edu/courses/spring09/V22.0202-002/wsclock-davis.html

---
# Отображенные файлы

.def[Отображенный файл] - область памяти, которую ОС синхронизирует с файлом: `mmap(2)`.
* Чтение из области приводит к чтению из файла
  * изначально ничего не отображено, вызывается обработчик исключения
  * новую страницу
  * инициирует чтение, блокирует процесс
  * когда оно завершается, отображает страницу в пространство процесса
  * разблокирует процесс
* Запись может приводить к записи в файл (shared) или только в копию в памяти (private)

<!--
```
extern void *mmap(void *addr, size_t len, int prot, int flags,
                int fildes, off_t off);

int fd = open(file, O_RDONLY);
char *m = mmap(NULL, 0x1000, PROT_READ, 0, fd, 0);
// operate on m
```
-->

Интересное свойство: ядро так же управляет страницами отображенных файлов
 * выгружать изменения на диск в произвольные моменты (например, переход active->inactive)
 * переиспользовать страницы для другого файла в этом или другом процессе, под память процеса
  * read-only отображения не нужно сбрасывать на диск
  * shared отображения пишутся в файл, private должы быть сохранены в swap

Политика вытеснения может учитывать природу страниц: память процесса или отображенный файл.

---
# Совместно используемая память

В один момент времени одна физическая страница может быть отображена в адресные пространства нескольких процессов.

.def[Общая память] (shmem) - механизм для межпроцессного взаимодействия (IPC)

fork - в том числе, создать копию адресного пространства

Динамические библиотеки - одна копия секции кода библиотеки отображется в разные процессы, каждый процесс обладает своей копией секции данных

Реализация fork:
* простая: скопировать все страницы.
* (.def[Copy-On-Write]) - более оптимальная:
  * отобразить в новый процесс старые страницы, пометить оба отображения как Read-Only
  * при попытке записи сделать копию, вернуть изначальные права доступа

---
# Реализация стека

Размер машинного стека ограничен достаточно большим числом, не разумно действительно выделять всю память сразу.

Память под стек выделяется лениво:
 * низ машинного стека защищается от любого обращения
 * когда стек вырастает так, что попадает в защищённую область, происходит исключение
 * обработчик выделяет несколько страниц и отображает их в низ стека, защищает следующие страницы от обращений

Другие области так же могут имеют специальные права доступа
* Код: X, может быть R, может быть W
* Данные: RW, может быть X

Системный вызов `mprotect(2)` позволяет задать прада доступа.


---
# Implicit Null Exception
```
        // r0 - object address
        cmp r0, #0
        beq throw_exception
        ld r0, [r0]
        ...
throw_exception:
        ...
```
 ---
```
signal_handler() {
        if (load_instruction && known_to_generate_NPE) {
                throw_exception()
        }
}
        ...
        // r0 - object address
        ld r0, [r0]
```
---
# Safepoint (barrier)

```
bool should_barrier;

...
if (should_barrier) {
        barrier();
}
...

should_barrier = true;
```
 ---
```
volatile char *should_barrier = mmap(NULL, 0x1000, PROT_READ,
                MAP_ANONYMOUS, -1, 0);
signal_handler() {
        barrier();
}
...
*should_barrier;
...
mprotect(should_barrier, 0x1000, PROT_NONE);
```

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
