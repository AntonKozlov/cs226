<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Управление памятью

---
# Литература

* Кнут, Искусство программирования, т.1, 2.5
* Wilson, Johnstone,... Dynamic Storage Allocation

---
# Управление памятью

.def[Управление памятью] - поддержка информации о блоках свободной/занятой памяти и удовлетворение запросов:
 * выделение памяти опредлённого размера
 * (опционально) освобождение ранее выделенной памяти

Существенные ограничения:
* Запросы поступают online (последующие запросы неизвестны)
* Выделенная память не может быть самостоятельно
 * отозвана
 * (опционально) перемещена


---
# Типы и примеры

Автоматическое управление памятью:
 * сборка мусора
 * подсчёт ссылок

Ручное:
 * Выделение в куче (malloc/free)
 * специализированные аллокаторы

Статическое:
 * глобальные данные
 * выделение на стеке

Сверху вниз уменьшается гибкость, но и уменьшаются накладные расходы, увеличивается предсказуемость (в смысле real-time)

---
# Иерархия выделения памяти

ОС выделяет память большими блоками. Приложению нужны маленькие блоки.

.def[Иерархия выделения памяти] - упорядоченное множество алокаторов памяти.

Примеры:

```asciidrawing

+-------------+      +-------------+
| malloc/free |      |     pool    |
+-------------+      +-------------+
|     OS      |      |      GC     |
+-------------+      +-------------+
                     |      OS     |
                     +-------------+
```

---
# Область изучения

Ручное выделение, обязательно:
 * освобождение ранее выделенной памяти
 * память не может быть перемещена

.def[Стратегия] - направлена на эксплуатирование особенностей в потоке запросов.

.def[Политика] - процедура размещения блоков памяти, допустимых стратегией.

.def[Механизм] набор алгоритмов и стурктур данных, реализующих политику.

Основные метрики:
 * фрагментация памяти
 * скорость выделения/освобождения

Метрики подсчитываются на записях .def[трасс] (последовательностях запросов) реальных программ.

---
# Фрагментация

.def[Внешняя] - наличие достаточного количества свободной памяти, которая не может быть выделена. Например, много несмежных блоков маленького размера. Причины появления:
 * точечные освобождения
 * смена фаз исполнения программы

.def[Внутренняя] - выделенный блок памяти больше, чем запрашиваемый. Причины появления:
 * отсутствует свободный блок подходящего размера
  * большие блоки могут быть разделены при удовлетворении запроса. После, смежные свободные блоки могут сливаться - превращаться в свободный блок большего размера
 * реализация не поддерживает блоки меньшего размера
 * политика не разделяет блоки, чтобы снизить внешнюю фрагментацию

---
# Последовательный поиск

Свободные блоки находятся в списке.

```asciidrawing

         free_list
         |
         v
+-------+----+---+---+--------------+----+---+---+
|#######|next|len|...|##############|NULL|len|...|
+-------+----+---+---+--------------+----+---+---+
           |                           ^
           |                           |
           +---------------------------+
```

Выделение: выбираем один из блоков, удаляем из списка; если блок больше запроса, то создаем новый свободный блок из остатка и добавляем в список.

Освобождение: добавляем в список свободных.

---
# Последовательный поиск
Выбор свободного блока:
* First Fit (*)
* Best Fit (*)
* Next Fit
* Worst Fit, Optimal Fit, Half Fit

Добавление в список свободных:
* LIFO
* FIFO (*)
* Address Ordered (*)

Проблемы масштабирования: с ростом количества блоков время поиска растёт

???

# Optimal fit
Campbell introduced an optimal fit policy which is a variant of next fit intended to improve the
chances of a good fit without too much cost in extra searching. It is not optimal in any useful
sense.

The basic idea is that the allocator looks forward through the linear list for a bounded number of
links recording the best t found It then proceeds forward looking for another fit at least as good as
what it found in that sample  range If it fails to find one before traversing the whole list it uses the best
fit it found in the sample range. That is it degenerates into exhaustive best fit search when the sample
contains the best fit.

## J. A. Campbell, A note on an optimal-fit method for dynamic allocation of storage
### Abstract
The problem of maintaining a free-storage list of variable-size blocks when requests for storage are also of various sizes is considered. A strategy is proposed which is directly related to the solution of the optimal stopping problem on a Markov chain of given length. Results of tests which show a superiority of this strategy over the conventional first-fit method under some conditions are presented.


---
# Слияние

.def[Слияние] - объединение освобожденного блока с соседними свободными.

```asciidrawing

         free_list
         |            free()
         v            v
+-------+----+---+---+--------------+----+---+---+
|#######|next|len|...|##############|NULL|len|...|
+-------+----+---+---+--------------+----+---+---+
           |                           ^
           |                           |
           +---------------------------+
```
```asciidrawing

         free_list
         |
         v
+-------+----+---+-------------------------------+
|#######|NULL|len|...............................|
+-------+----+---+-------------------------------+
```

---
# Замечания

"Небольшой" остаток можно не отделять: повышает внутреннюю фрагментацию, уменьшает внешнюю.

Слияние - дорогая операция (требует прохода по списку). Для удешевления, можно упорядочить свободные по адресам и проходить только часть списка.

Для освобождения нужно знать размер занятой области:
 * обязать пользователя указывать его
 * хранить размер выделенной области

```asciidrawing
Блок
|    Выделенная память
|    |
v    v
+----+---------------
|size|
+----+---------------
```


---
# Граничные маркеры


```asciidrawing
Блок
|         Выделенная память
|         |
v         v
+----+---+-----------+----+---+
|size|tag|           |size|tag|
+----+---+-----------+----+---+
```

tag: бит занят/свободен

По адресу блока (занятого или свободного) можно определить определить соседние блоки. Позволяет ускорить слияние.

size + tag можно хранить в одном слове.

---
# Двоичные близнецы

Вариант Linux'а:


```asciidrawing
  +---+---+   +-+   +-+
0 |map|   |<->| |<->| |
  +---+---+   +-+   +-+
1 |map|   |
  +---+---+   +-------+
2 |map|   |<->|       |
  +---+---+   +-------+
```
Память управляется блоками по степеням двойки. Для каждой степени:
 * список свободных
 * битовая карта, где каждому биту соответствует пара блоков:
  * 1 - оба заняты или свободны

Легко вычислить .def[близнеца] и определить его состояние => легко сливать
```
buddy_block_addr(block_addr, size) = block_addr ^ (1 << size)
```

Состояние (занят/свободен) хранится вне блоков: низкая внутренняя фрагментация.

Но не сливает смежные блоки, не являющиеся близнецами.

---
# Метод близнецов

Частный случай раздельных свободных (best fit) + быстрый способ слияния.

Большая фрагментация по сравнению с другими методами
* Двоичные близнецы
* Фибоначчи
* Взешенные

---
# Раздельные списки свободных

.def[Раздельный поиск] - отдельный список свободных блоков для каждого
 * размера
 * размера, округляемого вверх
 * класса размеров


.def[Раздельное хранение] - объекты разных размеров размещаются в разных областях => не нужно хранить размер каждого, только один размер для области

---
# Индексированный поиск

Используются структуры данных для поиска блока согласно требуемым характеристикам.

Пример: Best Fit по двоичному дереву, упорядоченному по размеру.

## Поиск по битовой шкале

Одна или несколько битовых шкал, хранящих пометки занят/свободен.

---
# Отложенное слияние

После освобождения сразу же возможно выделение => слитые блоки возможно сразу же придется разделить.

Можно не сливать сразу, а поддерживать несколько списков для недавно освобожденных блоков разных небольших размеров - кэш для аллокатора.

Очищать список:
 * частично или полностью
 * периодически/по исчерпанию основной кучи/по достижению предела длины
 * ...

Пример: Quick Fit

---
# Специализированные аллокаторы

* obstack
* pool
* slab

Литература:
 * Corbet, Rubini, Linux Device Drivers, Third Edition, ch. 8
 * Gorman, Understanding The Linux Virtual Memory Manager, ch. 8
 * Bonwick, The Slab Allocator


---
# Obstack

Стек-подобная структура (“object stack”).

Выделение - передвижение вершины obstack. Освобождение всего obstack.

Свойства: быстрое, эффективное, удобное, но опасное.

---
# pool (Embox)

```
POOL_DEF(my_pool, my_obj, OBJ_CNT);

void *pool_alloc(struct pool *pl);
void pool_free(struct pool *pl, void *obj);
```

---
# slab

```
struct foo {
	kmutex_t m;
	kcondvar_t cv;
	...
};

```

slab:
 * информация о типе объектов: размер, функция-конструктор,...
 * список кеш-блоков, каждый:
  * память под N объектов
  * состояние (полный/частично-свободный/свободный), статистика

* DRY
* учитывается в отладочной информации и статистике выделения
* позволяет другим подсистемам запрашивать память из SLAB

---
# slab - операции

## To allocate an object:
```
if (there’s an object in the cache) {
	take it (no construction);
} else {
	allocate memory;
	construct the object;
}
```

## To free an object

`return it to the cache (no destruction required);`

## To reclaim memory from the cache:
```
take some objects from the cache;
destroy the objects;
free the underlying memory;
```

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
