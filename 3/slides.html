<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Управление памятью

---
# Модель памяти

.def[Адресное пространство] (процесса) - множество адресов в памяти, к которым процесс может запросить доступ.

В адресном пространстве процесса находятся все данные приложения и его код.

Для защиты хотелось бы, чтобы память ядра не доступна для процессов для поддержание изоляции.

Физическая модель памяти:

```asciidrawing
0x0                                                 0x10000000
+-----+-------------+-----+------------+-----+-----+
|     |     RAM     |     |     IO     |     | Sys |
+-----+-------------+-----+------------+-----+-----+
```
Логическая: адресное пространство

```asciidrawing
+-------+-------+------+------+-----+-------+
| .text | .data | .bss | heap | ... | stack |
+-------+-------+------+------+-----+-------+
```

---
# Реализация

* Размещать данные процессов в общей памяти

```asciidrawing
       Процесс 1     Процесс 2
    +--------------+---------------------+
RAM | .text, ...   | .text, ...          | ...
    +--------------+---------------------+
```

Что делать с абсолютными адресами?
1. Исправлять абсолютные адреса на загрузке
1. Не использовать абсолютные адреса

<!--
Если потребуется выгрузить процесс во внешнюю память?
* Выгружать весь процесс целиком
-->

---
# .def[Сегментная модель памяти]

```asciidrawing cut
X
.    +-------+------------+-----+-----+---------+
.RAM | text1 |   text2    |     |data1| stack2  | ...
.    +-------+------------+-----+-----+---------+
.    ^       ^                  ^
X    |       |                  |
.    t1-base t2-base            d2-base
```

Адресное пространство - набор .def[сегментов] - участков переменной длины.
Память адресуется с помощью пары `сегмент:смещение`.

Может быть аппаратная поддержка:
* например, регистры .def[базы] и .def[размера]
* некорректное обращение приводит к исключению

<!--
Выгружать нужно сегменты целиком:
* процесс может работать, если он не обращается к выгруженному сегменту
  - например, выгружен один из нескольких сегментов данных
  - по исключению сегмент надо загрузить и позволить процессу продолжить работу
-->

---
# .def[Страничная модель]

.left[
```asciidrawing
         0x0     0xff..f
Процесс  +-------------+
      1  | .text, ...  |
         +-------------+

         0x0     0xff..f
Процесс  +-------------+
      2  | .text, ...  |
         +-------------+
```
```asciidrawing
Логическое пространство
+---+---+---+---+---+
|   |   |   |   |   |
+-+-+---+-+-+-+-+---+
  |       |   |
  +---+---+   +---+
+---+-v-+---+---+-v-+
|   |   |   |   |   |
+---+---+---+---+---+
Физическое пространство
```
]

Реализация адресного пространства с помощью .def[страниц] - участки памяти фиксированной длины.

Физические странцы памяти отображаются в адресное пространство процесса.
Обращение к логическому (.def[виртуальному]) адресу преобразуется в обращение к физическому адресу.
Существует соответствие между логическими адресами и физическими.

"Варианты" реализации:
* запретить доступ ко всей памяти, по исключению вычислять отображение и реализовывать эмуляцию инструкции работы с памятью
* аппратный модуль, который реализует отображение

---
# Системные вызовы

Некоторые системные вызовы для управления адресным пространством:

* brk/sbrk - передвинуть границу сегмента данных

```asciidrawing
                    brk()
+------+----------+           +-------+
| text |   heap   | -> ... <- | stack |
+------+----------+           +-------+
```

* mmap(ANON) - создать новую область памяти

```asciidrawing

            mmap()         mmap()
+------+    +-----------+  +-----------+
| text |....| heap part |..| heap part |....
+------+    +-----------+  +-----------+
```

---
# Управление памятью

.def[Управление памятью] - поддержка информации о блоках свободной/занятой памяти и удовлетворение запросов:
 * выделение памяти опредлённого размера
 * (опционально) освобождение ранее выделенной памяти

Существенные ограничения:
* Запросы поступают online (последующие запросы неизвестны)
* Выделенная память не может быть самостоятельно
 * отозвана
 * (опционально) перемещена

Литература:
* Кнут, Искусство программирования, т.1, 2.5
* Wilson, Johnstone,... Dynamic Storage Allocation

---
# Типы и примеры

Автоматическое управление памятью:
 * сборка мусора
 * подсчёт ссылок

Ручное:
 * Выделение в куче (malloc/free)
 * специализированные аллокаторы (pool, ...)

Статическое:
 * глобальные данные
 * выделение на стеке

```asciidrawing
 | уменьшается гибкость
 | уменьшаются накладные расходы
 v увеличивается предсказуемость (в смысле real-time)
```

---
# Иерархия выделения памяти

ОС выделяет память большими блоками. Приложению нужны маленькие блоки.

.def[Иерархия выделения памяти] - упорядоченное множество алокаторов памяти.

Примеры:

```asciidrawing

+-------------+      +-------------+
| malloc/free |      |     pool    |
+-------------+      +-------------+
|     OS      |      |      GC     |
+-------------+      +-------------+
                     |      OS     |
                     +-------------+
```

---
# Ручное выделение

Обязательно:
 * освобождение ранее выделенной памяти
 * память не может быть перемещена

Составные части:
* .def[Стратегия] - направлена на эксплуатирование особенностей в потоке запросов.
* .def[Политика] - процедура размещения блоков памяти, допустимых стратегией.
* .def[Механизм] - набор алгоритмов и стурктур данных, реализующих политику.

Основные метрики:
 * фрагментация памяти
 * скорость выделения/освобождения

Метрики подсчитываются на записях .def[трасс] (последовательностях запросов) реальных программ.

---
# Фрагментация

.def[Внешняя] - наличие достаточного количества свободной памяти, которая не может быть выделена. Например, много несмежных блоков маленького размера. Причины появления:
 * точечные освобождения
 * смена фаз исполнения программы

.def[Внутренняя] - выделенный блок памяти больше, чем запрашиваемый. Причины:
 * отсутствует свободный блок подходящего размера
  * большие блоки _могут_ быть разделены для удовлетворения запроса. <!--После, смежные свободные блоки могут сливаться - превращаться в свободный блок большего размера-->
 * реализация не поддерживает блоки меньшего размера
 * политика не разделяет блоки, чтобы снизить внешнюю фрагментацию

---
# Последовательный поиск

Свободные блоки находятся в списке.

```asciidrawing

         free_list
         |
         v
+-------+----+---+---+--------------+----+---+---+
|#######|next|len|...|##############|NULL|len|...|
+-------+----+---+---+--------------+----+---+---+
           |                           ^
           |                           |
           +---------------------------+
```

Выделение: выбираем один из блоков, удаляем из списка; если блок больше запроса, то создаем новый свободный блок из остатка и добавляем в список.

Освобождение: добавляем в список свободных.

---
# Последовательный поиск
Выбор свободного блока:
* First Fit (*)
* Best Fit (*)
* Next Fit
* Worst Fit, Optimal Fit, Half Fit

Добавление в список свободных:
* LIFO
* FIFO (*)
* Address Ordered (*)

Проблемы масштабирования: с ростом количества блоков время поиска растёт

???

# Optimal fit
Campbell introduced an optimal fit policy which is a variant of next fit intended to improve the
chances of a good fit without too much cost in extra searching. It is not optimal in any useful
sense.

The basic idea is that the allocator looks forward through the linear list for a bounded number of
links recording the best t found It then proceeds forward looking for another fit at least as good as
what it found in that sample  range If it fails to find one before traversing the whole list it uses the best
fit it found in the sample range. That is it degenerates into exhaustive best fit search when the sample
contains the best fit.

## J. A. Campbell, A note on an optimal-fit method for dynamic allocation of storage
### Abstract
The problem of maintaining a free-storage list of variable-size blocks when requests for storage are also of various sizes is considered. A strategy is proposed which is directly related to the solution of the optimal stopping problem on a Markov chain of given length. Results of tests which show a superiority of this strategy over the conventional first-fit method under some conditions are presented.


---
# Слияние

.def[Слияние] - объединение освобожденного блока с соседними свободными.

```asciidrawing

         free_list
         |            free()
         v            v
+-------+----+---+---+--------------+----+---+---+
|#######|next|len|...|##############|NULL|len|...|
+-------+----+---+---+--------------+----+---+---+
           |                           ^
           |                           |
           +---------------------------+
```
```asciidrawing

         free_list
         |
         v
+-------+----+---+-------------------------------+
|#######|NULL|len|...............................|
+-------+----+---+-------------------------------+
```

---
# Замечания

"Небольшой" остаток можно не отделять: повышает внутреннюю фрагментацию, уменьшает внешнюю.

Слияние - дорогая операция (требует прохода по списку). Для удешевления, можно упорядочить свободные по адресам и проходить только часть списка.

Для освобождения нужно знать размер занятой области:
 * обязать пользователя указывать его
 * хранить размер выделенной области

```asciidrawing
Блок
|    Выделенная память
|    |
v    v
+----+---------------
|size|
+----+---------------
```


---
# Граничные маркеры


```asciidrawing
Блок
|         Выделенная память
|         |
v         v
+----+---+-----------+----+---+
|size|tag|           |size|tag|
+----+---+-----------+----+---+
```

tag: бит занят/свободен

По адресу блока (занятого или свободного) можно определить определить соседние блоки. Позволяет ускорить слияние.

size + tag можно хранить в одном слове.

---
# Двоичные близнецы

Вариант Linux'а:


```asciidrawing
  +---+---+   +-+   +-+
0 |map|   |<->| |<->| |
  +---+---+   +-+   +-+
1 |map|   |
  +---+---+   +-------+
2 |map|   |<->|       |
  +---+---+   +-------+
```
Память управляется блоками по степеням двойки. Для каждой степени:
 * список свободных
 * битовая карта, каждый бит - пара блоков: 1 - оба заняты или свободны

Легко вычислить .def[близнеца] и определить его состояние => легко сливать
```
buddy_block(block, size) = block ^ (1 << size);
```
```
alloc/free(block, size_log2):
  binary_map[(block-base) >> (1+(size_log2)] ^= 1

```


---
# Метод близнецов

Частный случай раздельных свободных (best fit) + быстрый способ слияния.

Состояние (занят/свободен) хранится вне блоков:
 * низкая внутренняя фрагментация для объектов степени 2.

Большая фрагментация:
* для небольших объектов
* не сливает смежные блоки, не являющиеся близнецами

Бывают
* Двоичные близнецы
* Фибоначчи
* Взешенные

---
# Раздельные списки свободных

.def[Раздельный поиск] - отдельный список свободных блоков для каждого
 * размера
 * размера, округляемого вверх
 * класса размеров


.def[Раздельное хранение] - объекты разных размеров размещаются в разных областях => не нужно хранить размер каждого, только один размер для области

---
# Индексированный поиск

Используются структуры данных для поиска блока согласно требуемым характеристикам.

Пример: Best Fit по двоичному дереву, упорядоченному по размеру.

## Поиск по битовой шкале

Одна или несколько битовых шкал, хранящих пометки занят/свободен.

---
# Отложенное слияние

После освобождения сразу же возможно выделение => слитые блоки возможно сразу же придется разделить.

Можно не сливать сразу, а поддерживать несколько списков для недавно освобожденных блоков разных небольших размеров - кэш для аллокатора.

Очищать список:
 * частично или полностью
 * периодически/по исчерпанию основной кучи/по достижению предела длины
 * ...

Пример: Quick Fit

---
# Специализированные аллокаторы

* obstack
* pool
* slab

Литература:
 * Corbet, Rubini, Linux Device Drivers, Third Edition, ch. 8
 * Gorman, Understanding The Linux Virtual Memory Manager, ch. 8
 * Bonwick, The Slab Allocator


---
# Obstack

Стек-подобная структура (“object stack”).

Выделение - передвижение вершины obstack. Освобождение всего obstack.

```c
struct obstack {
        void *base;
        void *next;
        void *end;
}

alloc(size) {
        ...
        void *r = next;
        next += size;
        return r;
}
```

Свойства: быстрое, эффективное, удобное, но опасное.

---
# pool (Embox)

```c
struct pool {
        char *mem;
        unsigned long membsz;
        char *freestart;
        char *freeend;
        struct pool_free_block {
                struct pool_free_block *next;
        } *free;
}
void *pool_alloc(struct pool *p) {
        struct pool_free_block *fb = p->free;
        if (fb) {
                p->free = fb->next;
                return fb;
        }
        if (p->freestart < p->freeend) {
                void *r = p->freestart;
                p->freestart += p->membsz;
                return r;
        }
        return NULL;
}
```

---
# slab

```
struct foo {
	kmutex_t m;
	kcondvar_t cv;
	...
};

```

slab:
 * информация о типе объектов: размер, функция-конструктор,...
 * список кеш-блоков, каждый:
  * память под N объектов
  * состояние (полный/частично-свободный/свободный), статистика

* DRY
* учитывается в отладочной информации и статистике выделения
* позволяет другим подсистемам запрашивать память из SLAB

---
# slab - операции

## To allocate an object:
```
if (there’s an object in the cache) {
	take it (no construction);
} else {
	allocate memory;
	construct the object;
}
```

## To free an object

`return it to the cache (no destruction required);`

## To reclaim memory from the cache:
```
take some objects from the cache;
destroy the objects;
free the underlying memory;
```

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
