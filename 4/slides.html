<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Процессы

---
# Определения

.def[Процесс] - исполняемая программа.
 * программа и её состояние
 * экземпляр виртуальной машины

.def[Адресное пространство] (процесса) - множество адресов в памяти, к которым процесс может запросить доступ.

В адресном пространстве процесса находятся все данные приложения и его код.

Для защиты, память ядра не доступна для процессов для поддержание изоляции.

.def[Потоки] - процессы, обладающие общим адресным пространством.

---
# Модель памяти

Физическая:

```asciidrawing
0x0                                                 0x10000000
+-----+-------------+-----+------------+-----+-----+
|     |     RAM     |     |     IO     |     | Sys |
+-----+-------------+-----+------------+-----+-----+
```
Логическая: адресное пространство

```asciidrawing
+-------+-------+------+------+-----+-------+
| .text | .data | .bss | heap | ... | stack |
+-------+-------+------+------+-----+-------+
```

---
# Реализация

```asciidrawing
       Процесс 1     Процесс 2
    +-------------+-------------+
RAM | .text, ...  | .text, ...  | ...
    +-------------+-------------+
```

Использование абсолютных адресов:
1. Не использовать абсолютные адреса
1. Исправлять абсолютные адреса на загрузке
1. (+ изоляция) Ввести и использовать аппаратные регистры .def[базы] и .def[размера] области памяти процесса

.def[Сегментная модель памяти] - адресное пространство состоит из набора .def[сегментов] - участков переменной длины. Программа адресует память с помощью пары (сегмент:смещение).

FIXME: Сегменты вытесняются целиком.

---
# Страничная модель

.left[
```asciidrawing
         0x0     0xff..f
Процесс  +-------------+
      1  | .text, ...  |
         +-------------+

         0x0     0xff..f
Процесс  +-------------+
      2  | .text, ...  |
         +-------------+
```
```
Логическое пространство
┌───┬───┬───┬───┬───┐
│   │   │   │   │   │
└─┬─┴───┴─┬─┴─┬─┴───┘
  │       │   │
  └───┬───┘   └───┐
┌───┬─v─┬───┬───┬─v─┐
│   │   │   │   │   │
└───┴───┴───┴───┴───┘
Физическое пространство
```
]

Весь диапазон виртуальной и физической памяти делится на участки фиксированной длины - .def[страницы].

Физические странцы памяти отображаются в адресное пространство, обращение к логическому (.def[виртуальному]) адресу приводит к обращению к физическому адресу.

.def[Страничная модель память] - реализация адресного пространства с помощью страниц.

Некоторые страницы виртуальной памяти могут быть отображением в "запрещённые" области физической памяти или быть неотображенными.

Отображение адресов - частая и сложная операция.

---

.left[
```asciidrawing
P - размер страницы

         N            P        0
 Virtual +------------+--------+
    addr |    idx     | offset |
         +------------+--------+

   +----------+
  0|  record  |
   +----------+
  1|  record  |
   +----------+
  .|  record  |
  .+----------+
  .|  record  |
   +------+---+
idx| base | f |
   +------+---+
   |  record  |
   +----------+

Physical +------------+--------+
    addr |    base    | offset |
         +------------+--------+
         N            P        0
```
]

Отображение aппаратно ускоряется с помощью модуля процессора Memory Management Unit (MMU).

Может задаваться с помощью таблицы (слева).

Запись может нести дополнительную информацию:

```asciidrawing
+---------+---+---+---+---+---+---+---+
| phyaddr | R | W | X | C | M | A | E |
+---------+---+---+---+---+---+---+---+
```
* R/W/X - разрешение на чтение/запись/исполнение
* С - разрешение кэшировать
* M - был ли доступ на запись
* A - был ли доступ на чтение
* E - другие поля записи определены

---

Таблица может быть большой, например, для 32 битной архитектуры

```
4б [запись] * (4Гб [пространство] / 4Kб [страница]) = 4Мб [таблица]
```

.left[
```asciidrawing
         N             P        0
 Virtual +------+------+--------+
    addr | idx1 | idx2 | offset |
         +------+------+--------+
                           t2 base
    +-------------+  +---->+-------------+
    |    record   |  |     |    record   |
    +-------------+  |     +---------+---+
    |    record   |  | idx2|   base  | f |
    +-------------+  |     +---------+---+
    |    record   |  |     |    record   |
    +---------+---+  |     +-------------+
idx1| t2 base | F +--+
    +---------+---+
    |    record   |
    +-------------+

Physical +-------------+--------+
    addr |     base    | offset |
         +-------------+--------+
         N             P        0
```
]

Большая часть страниц не отображена. Решение - многоуровневая таблица.

Просмотр многоуровненвых таблиц плохо сказывается на производительности.
Для ускорения вводят .def[Translation Lookaside Buffer] (TLB) - кеш отображений.

Требуется управление кешом: инвалидация при обновлении таблиц,...

---
# Системные вызовы
Системные вызовы для управления адресным пространством:

* brk()

```asciidrawing
                    brk()
+------+----------+           +-------+
| text |   heap   | -> ... <- | stack |
+------+----------+           +-------+
```

* mmap(ANON)

```asciidrawing

            mmap()         mmap()
+------+    +-----------+  +-----------+
| text |....| heap part |..| heap part |....
+------+    +-----------+  +-----------+
```

* mprotect()

* ...

---
# Жизнь процесса

1. Создание
2. Выполнение
3. Завершение


---
# Создание

1. Инициализация системы.

 В Unix: ядро запускает первый процесс init -- процесс отвечающий за запуск других процессов
2. Существующий процесс создает другой процесс.

 В Unix: системный вызов fork

---
# fork

Системный вызов `fork(2)` создает полную копию вызывающего процесса, за исключением кода возврата системного вызова.

```
$ man 2 fork
```

Создаются независимые копии:
 * адресного пространства
 * текущего состояния (набор значений регистров)
 * ресурсы ОС

По коду возврата можно определить, исполняется ли новый или оригинальный процесс.

Неточный пример:

```
	...
	int res = fork(); // системный вызов
	if (res == 0) {
		// new process
	} else {
		// old process
	}
```
---
# Copy-On-Write

```asciidrawing
+---+---+---+---+---+   +---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |
+-+-+---+---+-+-+---+   +-+-+---+---+---+-+-+
  |           |           |               |
  |           |           |               |
  |       +---+-----------+               |
  |       |   |                           |
  +---+---+   |   +-----------------------+
      |       |   |
+---+-v-+---+-v-+-v-+
|   |   |   |   |   |
+---+---+---+---+---+
```

---
# fork

```
	...
	int res = fork(); // код возврата 0
	if (res == 0) {
		// new process, исполняем это
	} else {
		// old process
	}
```
 ---

```
	...
	int res = fork(); // код возврата 0
	if (res == 0) {
		// new process, исполняем это
	} else {
		// old process
	}
```

---
# Иерархия процессов

При fork оригинальный и новый процессы становится .def[родителем] и .def[ребенком].

Процессы в системе образуют дерево иерархии.

```asciidrawing
+--------+
| parent |
+--------+
    |
    +---->...
    |
    |
    +---->...
    |
    |     +-------+
    +---->| child |
          +-------+
```

---
# Идентификация процессов

Процессы идентифицируются числом типа `pid_t`

```
	pid_t parent = getpid(); // получить id текущего процесса
	pid_t child = fork();
	if (child == 0) {
		// child process; child в родителе == getpid()
	} else {
		// parent process
	}
```

---
# exec

Системный вызов `exec` -- заместить текущий процесс программой с диска, с инициализацией начального состояния

Используется вместе с `fork` для создания нового процесса, исполняющего другие програмыы, а не только копии оригинального процесса.

example.c:

```
static int global = 314;
int main(int argc, char *argv[]) {
	printf("%d\n", global);
	return 0
}
```
 ---
```
	...
	pid_t child = fork();
	if (child == 0) {
		execl("./example", NULL);
	}
	...
```

---
# Завершение процесса

1. Выход (с кодом завершения):
```
	const int success = 0;
	const int error = 1; // Любой не 0
	exit(success);
```

2. Получение сигнала:
 * неперехватываемого SIGKILL
 * перехватываемого сигнала без установленного обработчика и поведением по умолчанию "завершение"

Замечания:
 * существуют перехватываемые сигналы с поведением по умолчанию "игнорировать"
<!--* при установке обработчика можно изменить поведение c "завершения" на произвольное -->

<!--
# Сигналы

Процесс получает сигнал:
 * сгенерированный операционной системой как результат выполнения программы (примерно: внутреннее исключение процессора):
  * SIGSEGV -- ошибка изоляции процесса
  * SIGILL -- исполнение невалидной инструкции процессора
  * ...
 * посланный другим процессом (очень примерно: прерывание от устройства)
-->

---
# Подбор процесса

* .def[Подбор] -- получение родительским процессом информации о завершении дочернего, в том числе, кода возврата.

Часть ресурсов дочернего процесса не освобождается после его выхода, а сохраняется до подбора:
 * идентификатор процесса
 * память под код возврата

---
# waitpid

Подбор реализуется системным вызовом `waitpid(2)`

```
	pid_t child = fork();
	if (child == 0) {
		execl("./example", NULL);
	}
	int cstat;
	const int waitflags = 0;
	if (-1 == waitpid(child, &cstat, waitflags)) {
		perror("waitpid");
	}
	int childcode = WIFEXITED(cstat) ? WEXITSTATUS(cstat) : -1;
```

Выход из `waitpid` родительского процесса в примере происходит только тогда, когда дочерний процесс завершается.

Может быть отключено флагом `WNOHANG`

---
# Перенаправления

```
$ seq 1 100 > temp.txt
$ grep 2 < temp.txt
```

```
$ seq 1 100 | grep 2
```

---
# Файловые дескрипторы

* .def[Файловый дескриптор] -- объект операционной системы поддерживающий файловый интерфейс (`read(2)`, `write(2)`,...).

Для защиты, объекты ОС находятся в адресном пространстве ядра, т.е. недоступны процессу напрямую.

С процессом ассоциирована таблица (массив) файловых дескрипторов, находящаяся так же в адресном пространстве ядра.

Процесс оперирует с файловыми дескрипторами с помощью системных вызовов и индексов дескрипторов в таблице.

---
# "Всё есть файл" (1)

Многие сущности представлены могут быть представлены в качестве файловых дескрипторов

```asciidrawing
      +----------+
 +--->| keyboard |
 |    +----------+
 |
 |    +---------+
 | +->| display |
 | |  +---------+
 | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	char buf[128];
	int r = read(0, buf, sizeof(buf));
	write(1, buf, r);
```

---
# Создание элементов таблицы

```asciidrawing
      +---------+
   +->| display |
   |  +---------+
   |
   |
   |    +------+
   | +->| file |
   | |  +------+
   | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	int fd = open("test.txt", O_WRONLY);
	write(fd, content...);
```
---
# Изменение таблицы

```asciidrawing
        +------+
   +-+->| file |
   | |  +------+
   | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	int fd = open("test.txt", O_WRONLY);
	dup(fd, 1);
```
---
# Удаление элементов

```asciidrawing
        +------+
   +--->| file |
   |    +------+
   |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	int fd = open("test.txt", O_WRONLY);
	dup2(fd, 1);
	close(fd);
```

---
# `> text.txt`

`fork` копирует таблицу ресурсов.

```
$ seq 1 100 > test.txt
```

```
	...
	pid_t child = fork();
	if (child == 0) {
		close(1);
		int fd = open("text.txt", O_WRONLY);
		assert(fd == 1);
		execl("/usr/bin/seq", "1", "100", NULL);
	}
	if (-1 == wait(NULL)) {
		perror("wait");
	}
```

---
# pipe

```
$ seq 1 100 | grep 2
```

Системный вызов `pipe(2)` создает буфер (в ядре ОС) и 2 ассоцированных с ним дескриптора: для записи и для чтения.

```asciidrawing
+---------------+    +-------------+    +--------------+
| pipe write fd |--->| pipe buffer |--->| pipe read fd |
+---------------+    +-------------+    +--------------+
       ^                                       ^
       |                                       |
    +-+-+-+-                                  +-+-+-+-
    +-+-+-+-                                  +-+-+-+-
       1                                       0
............................................................
   +-----------+                             +-----------+
   | process 1 |                             | process 2 |
   +-----------+                             +-----------+

   write(1, ...)                             read(0, ...)
```

---
# Замечания

pipe позволяет реализовывать программы-фильтры (grep, sed, ...).

Для диагностических ошибок выделен файловый дескриптор 2 (STDERR_FILE). Например,
```
$ cat notexist | grep 1
cat: notexist: Нет такого файла или каталога
```

Когда в буфере нет данных, читающий процесс приостанавливается. Аналогично, когда буфер полностью заполняется, пприостанавливается пишущий процесс.

<!--
# Д/З

Перенести ваш шелл под Linux:

```
$ echo Hello, World
Hello, World
```
```
$ echo test1; echo test2
test1
test2
```

Добавить перенаправление pipe

```
$ seq 1 100 | grep 2 | grep 0
```

Можно считать, что и все программы лежат в `/usr/bin`

https://github.com/AntonKozlov/eduos/tree/next/shell
```
$ make -C shell test
```
```
$ (cd shell; make test)
```
-->
    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
