<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Вытесняющее планирование

---
# Мотивация

С точки зрения кооперативного планирования, зависшие и интенсивные вычислительные задачи (с небольшим количеством ввода/вывода) одинаково плохи:
 * блокируют исполнение других задач
 * могут быть только завершены (по истечению отрезка времени)

Можно было бы решать синтетическим разделением длинных задач на небольшие:
 * требует модификации программ
 * ручное разделение не оптимально (квалификация, недостаток знания о системе)

---
# Определения

.def[Вытесняющее планирование] - планирование, при котором выполнение процесса может быть приостановлено.

.def[Переключение контекста] - процесс смены текущего исполняемого процесса:
 * изменение данных планировщика (указатель на текущий процесс, ...)
 * изменение состояния процессора (значения регистров, режима исполнения, ...)

При переключении контекста, состояние вытесняемого процесса сохраняется, так что в будущем можно вернуться к исполнению этого процесса.

.def[Квант времени процесса] - максимальный отрезок времени непрерывного исполнения процесса.

.def[Пвсево-параллельное исполнение] - переключение процессов с достаточно большой скоростью, создающее впечатление параллельного исполнения.

---
# Переключение

Переключение проводится:
 * принудительно
 * добровольно

.def[Принудительное переключение] происходит из обработчика прерывания, например:
 * таймера - истек квант вермени
 * ввода/вывода - доступен ввод/вывод, который ожидает более приоритетный процесс.

Принудительное переключение:
 * асинхронное событие
 * является .def[отложенным] - производится после обработки прерывания, до выхода в пользовательский режим (bottom half).

.def[Критическая секция по отношению к IRQ] - участок потока исполнения, во время которого не может начаться обработка прерывания

---
# Реализация


```asciidrawing
  main      switch
  |         |
  +--+------+---+                +----
--+  |##########+----------------+    ...>
  +--+----------+                +----
     |          |
   irq    exit to
        userspace

                +-----+----------+
----------------+     |##########+----...>
                +-----+----------+
                      |          |
                    irq    exit to
                         userspace
+--+
|  | Время проведённое в выполнении кода приложения
+--+

+--+
|##| Время в коде ядра
+--+
```
---

.def[Добровольное переключение] - переключение из системного вызова, когда он должен завершиться только после наступления определенного события.

```asciidrawing
     main
     |
     +--+-------------+     +----
-----+  |#############+-----+####...>
     +--+-------------+     +----
        |             |     |
os_sys_read  ctx_switch     ctx_switch

                      +-----+
----------------------+#####+----...>
                      +-----+
                      |     |
             ctx_switch     ctx_switch
```

Добровольное переключение:
 * синхронное событие
 * является .def[реальным] - производится сразу

Почему добровольное переключение не сделать отложенным?

---
# Ожидание события

Событие (2) может произойти после начала его ожидания (1) но до переключения контекста (3).

```asciidrawing
    (1) if (!ready) {
     |
     +-------------+
-----+#############|
     +-----+-------+
           |       |
      irq (2)     (3) ctx_switch
```

1. Выключение прерывания на длительный срок, с (1) до (3)
2. Определение протокола оповещения о событии:
 * (1) Проецесс выставляет бит WAIT до проверки на событие
 * (2) Прерывание стирает бит WAIT после (1), но до (3)
 * (3) ctx_switch выключает прерывания, проверяет бит WAIT:
      * 1 - событие ещё не произошло, выполняет переключение
      * 0 - событие произошло, выходим сразу же (или помечаем задачу как READY)

---
### Системный вызов и квант времени

Может ли событие (например, истечение кванта времени) во время исполнения системного вызова запустить принудительное переключение?

Частный случай вопроса: когда обрабатываются top и bottom части прерываний, если возникают во время системного вызова?

* невытесняемое (nonpreemtive) ядро: не запускать bottom
 * +: в каждый момент времени не больше одного процесса исполняются в режиме ядра (1 процессор), простая синхронизация
 * +: синхронное исполнение => более простой анализ времени исполнения и корректности
 * -: долгие системные вызовы увеличивают задержку обработки прерывания
* вытесняемое (preemtive) ядро: запускать bottom
 * всё наборот
* seL4: не запускать top, но вставить проверки на ожидание прерывания на длинных путях исполнения

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
