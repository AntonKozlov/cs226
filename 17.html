<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="slides.css">
    <script src="remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Виртуальная память

---
# Модель памяти

Физическая:

```asciidrawing
0x0                                                 0x10000000
+-----+-------------+-----+------------+-----+-----+
|     |     RAM     |     |     IO     |     | Sys |
+-----+-------------+-----+------------+-----+-----+
```
Логическая: адресное пространство

```asciidrawing
+-------+-------+------+------+-----+-------+
| .text | .data | .bss | heap | ... | stack |
+-------+-------+------+------+-----+-------+
```

---
# Реализация

```asciidrawing
       Процесс 1     Процесс 2
    +-------------+-------------+
RAM | .text, ...  | .text, ...  | ...
    +-------------+-------------+
```

Использование абсолютных адресов:
1. Не использовать абсолютные адреса
1. Исправлять абсолютные адреса на загрузке
1. (+ изоляция) Ввести и использовать аппаратные регистры .def[базы] и .def[размера] области памяти процесса

Памяти может быть меньше чем необходимо для размещения всех процессов.

.def[Swapping] - сбросить адресное пространство памяти процесса на диск

.def[Сегментная модель памяти] - адресное пространство состоит из набора .def[сегментов] - участков переменной длины. Программа адресует память с помощью пары (сегмент:смещение). Сегменты вытесняются целиком.

---
# Виртуальная память

.def[Виртуальная память] - реализация адресного пространства, предоставляет непрерывное множество адресов.

.left[
```asciidrawing
         0x0     0xff..f
Процесс  +-------------+
      1  | .text, ...  |
         +-------------+

         0x0     0xff..f
Процесс  +-------------+
      2  | .text, ...  |
         +-------------+
```
```
Логическое пространство
┌───┬───┬───┬───┬───┐
│   │   │   │   │   │
└─┬─┴───┴─┬─┴─┬─┴───┘
  │       │   │
  └───┬───┘   └───┐
┌───┬─v─┬───┬───┬─v─┐
│   │   │   │   │   │
└───┴───┴───┴───┴───┘
Физическое пространство
```
]

Весь диапазон виртуальной и физической памяти делится на участки фиксированной длины - .def[страницы].

Физические странцы памяти отображаются в адресное пространство, обращение к логическому (.def[виртуальному]) адресу приводит к обращению к физическому адресу.

Некоторые страницы виртуальной памяти могут быть отображением в "запрещённые" области физической памяти или быть неотображенными.

Позволяет размещать часть памяти процесса (подмножество страниц) на диске - .def[Paging]

---

Отображение адресов - частая и сложная операция.

.left[
```asciidrawing
P - размер страницы

         N            P        0
 Virtual +------------+--------+
    addr |    idx     | offset |
         +------------+--------+

   +----------+
  0|  record  |
   +----------+
  1|  record  |
   +----------+
  .|  record  |
  .+----------+
  .|  record  |
   +------+---+
idx| base | f |
   +------+---+
   |  record  |
   +----------+

Physical +------------+--------+
    addr |    base    | offset |
         +------------+--------+
         N            P        0
```
]

Поэтому отображение выполняется аппаратно - с помощью модуля процессора Memory Management Unit (MMU).

Может задаваться с помощью таблицы (слева).

Запись может нести дополнительную информацию:

```asciidrawing
+---------+---+---+---+---+---+---+---+
| phyaddr | R | W | X | C | M | A | E |
+---------+---+---+---+---+---+---+---+
```
* R/W/X - разрешение на чтение/запись/исполнение
* С - разрешение кэшировать
* M - был ли доступ на запись
* A - был ли доступ на чтение
* E - другие поля записи определены

---

Таблица может быть большой, например, для 32 битной архитектуры

```
4б [запись] * (4Гб [пространство] / 4Kб [страница]) = 4Мб [таблица]
```

.left[
```asciidrawing
         N             P        0
 Virtual +------+------+--------+
    addr | idx1 | idx2 | offset |
         +------+------+--------+
                           t2 base
    +-------------+  +---->+-------------+
    |    record   |  |     |    record   |
    +-------------+  |     +---------+---+
    |    record   |  | idx2|   base  | f |
    +-------------+  |     +---------+---+
    |    record   |  |     |    record   |
    +---------+---+  |     +-------------+
idx1| t2 base | F +--+
    +---------+---+
    |    record   |
    +-------------+

Physical +-------------+--------+
    addr |     base    | offset |
         +-------------+--------+
         N             P        0
```
]

Большая часть страниц не отображена. Решение - многоуровневая таблица.

Просмотр многоуровненвых таблиц плохо сказывается на производительности.
Для ускорения вводят .def[Translation Lookaside Buffer] (TLB) - кеш отображений.

Требуется управление кешом: инвалидация при обновлении таблиц,...

---
# Paging

При обращении по неотображенному участку виртуальной памяти происходит исключение.

Реализация paging:
1. В начальный момент времени все страницы находятся в памяти
2. При запросе дополнительной памяти, который не может быть удовлетворён, тогда ядро:
 * ищет страницу-жертву, которая будет вытеснена на диск
 * иницирует вытеснение
 * по завершению, помечает отображение как вытесненное, страница считается пустой
3. В течение работы может произойти обращение к вытесненной странице, тогда ядро:
 * удостоверяется, что запрос произведён к вытесненной странице
 * определяется новая странца-жертва, которая вытесняется
 * на место жертвы загружается целевая странца
 * ядро выходит из исключения с повтором инструкции

---
# Выбор жертвы

Выбор страницы-жертвы существенно влияет на производительность.

При неудачном выборе, система будет находится в постоянной выгрузке/загрузке страниц, выполняя небольшое количество инструкций программ (полезной работы).
Ситуация называется .def[пробуксовкой].

First In First Out (FIFO):
 * поддерживать список страниц, упорядоченный по времени загрузки, от самой старой страницы
 * вытеснять самую старую страницу
 * вытесняет потенциально используемые страницы.

Второй шанс:
 * модификация FIFO
 * если бит A самой старой страницы установлен, перенести её в конец списка, перейти к следующей
 * вырождается в предыдущий алгоритм, если A установлен у всех страниц

---

Часы:
 * Второй шанс над кольцом вместо списка
 * не нужно переносить элементы, достаточно перейти к следующему элементу

Not Recently Used (NRU):
 * периодически сбрасывать флаги A/M
 * при необходимости вытеснения выбрать страницу из первого непустого класса (по битам A/M): 0/0, 0/1, 1/0, 1/1

Least Recently Used (LRU):
 * вытеснять страницу, которая использовалась наиболее давно
 * в чистом виде учитывать время трудно

Not Frequently Used (NFU):
 * поддерживать счётчик обращений (аппаратно/периодически сбрасывать A, запоминая значение)
 * должно быть .def[старение] счётчика - уменьшение значения со временем

---

Рабочий набор:
 * w(k,t) - набор из страниц, которым получили доступ последние k обращений к памяти за последние t времени. Можно рассматривать w(inf, const)
 * вытеснять не попадающие в рабочий набор
 * загружать не по одной странице по исключению, а рабочий набор или его часть

WSClock:
 * рабочий набор + часы
 * минимизирует обход страниц в простом Рабочем наборе

http://www.cs.nyu.edu/courses/spring09/V22.0202-002/wsclock-davis.html

---
# Совместно используемая память

В один момент времени одна физическая страница может быть отображена в адресные пространства нескольких процессов.

1. fork - создает копию адресного пространства. Простая реализация - скопировать все страницы. Более оптимальная - отобразить в новый процесс старые страницы, пометив оба отображения как Read-Only. При попытке записи сделать копию (.def[Copy-On-Write]), вернуть изначальные права доступа. Пример ленивого копирования.
1. .def[Общая память] (shmem) - механизм для межпроцессного взаимодействия (IPC)
1. Динамические библиотеки - одна копия секции кода библиотеки отображется в разные процессы, каждый процесс обладает своей копией секции данных

---
# Отображенные файлы

.def[Отображенный файл] - область памяти, которую ОС синхронизирует с файлом. Чтение/запись в область приводят к операциям с файлом

```
extern void *mmap(void *addr, size_t len, int prot, int flags,
                int fildes, off_t off);

int fd = open(file, O_RDONLY);
char *m = mmap(NULL, 0x1000, PROT_READ, 0, fd, 0);
// operate on m
```

Для реализации mmap может использоватьсься DMA, но нужно иметь ввиду, что линейный участок адресного пространства процесса может не быть линейным в физическом пространстве, где DMA оперирует.

---
# Неоднородность памяти

* Код: X, может быть R
* Данные: RW
* Стек: RW, специальная обработка записи в нижнюю область стека

---
# Implicit Null Exception
```
        // r0 - object address
        cmp r0, #0
        beq throw_exception
        ld r0, [r0]
        ...
throw_exception:
        ...
```
 ---
```
signal_handler() {
        if (load_instruction && known_to_generate_NPE) {
                throw_exception()
        }
}
        ...
        // r0 - object address
        ld r0, [r0]
```
---
# Safepoint (barrier)

```
bool should_barrier;

...
if (should_barrier) {
        barrier();
}
...

should_barrier = true;
```
 ---
```
volatile char *should_barrier = mmap(NULL, 0x1000, PROT_READ,
                MAP_ANONYMOUS, -1, 0);
signal_handler() {
        barrier();
}
...
*should_barrier;
...
mprotect(should_barrier, 0x1000, PROT_NONE);
```

    </textarea>
    <script src="slides.js" type="text/javascript"></script>
  </body>
</html>
