<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="slides.css">
    <script src="remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Блочные устройства и файловые системы

---
# Литература

* Таненбаум, Современные ОС, Глава 4
* https://www.kernel.org/doc/Documentation/filesystems/vfs.txt
* http://www.tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html
* http://www.win.tue.nl/~aeb/linux/vfs/trail-3.html
* http://lwn.net/Articles/13325/
* http://habrahabr.ru/company/spbau/blog/218833/
* http://www.virtualblueness.net/Ext2fs-overview/Ext2fs-overview-0.1.html

---
# Иерархия памяти

```asciidrawing
+------------------------+
|       Регистры         |
+------------------------+
| Кеш оперативной памяти |
+------------------------+
|   Оперативная память   |
+------------------------+
|   Блочные устройства   |
+------------------------+
```

Блочные устройства:
* Магнитная лента
* Жесткий диск
* Твердотельный (flash) диск
* Оптический диск

Свойства:
* Используется для долговременного хранения данных
* Самый медленный интерфейс
* Самый большой объем

---
### Взаимодействие с устройствами

.def[Блочные устройства] - энергонезависимые устройства хранения данных, оперирующие .def[блоками] - последовательностями байт фиксированного размера.

Варианты взаимодействия (для чтения):
 * Опрос (polling):
  1. Установить адрес блока
  1. Инициировать чтение (во внутренний буфер устройства)
  1. Ожидать, пока данные не будут прочитаны
  1. Скопировать прочитанные данные в оперативную память
 * Опрос с прерыванием:
  1. Установить адрес блока
  1. Установить обработчик прерывания, инициировать чтение
  1. ...
  1. В обработчике прерывания проверить готовность данных, скопировать в оперативную память
 * DMA:
  1. Установить адрес блока
  1. Установить базовый адрес в памяти
  1. Установить обработчик прерывания, инициировать чтение
  1. ...

---
# Файл

.def[Файл] - логический информационный блок, моделирующий блочное устройство. Содержит данные и метаинформацию (аттрибуты):
* размер
* дата создания/изменения/доступа
* тип - `обычный`
* владелец
 * идентификатор пользователя
 * ... группы пользователей
* права:
 * блок из трёх бит: чтение, запись, исполнение
 * три блока бит для: владельца, группы владельцев, всех остальных

На устройстве файл представляется набором блоков.

---
# Взаимодействие с файлами

Файл представляет .def[последовательный] интерфейс в возможностью .def[перемотки]:
* `ssize_t read(int fildes, void *buf, size_t nbyte)`
* `ssize_t write(int fildes, const void *buf, size_t nbyte)`
* `off_t lseek(int fildes, off_t offset, int whence)`
* `int close(int fildes)`

Данные:
* размер единицы данных:
 * байт
 * запись - блок фиксированного размера
* формат данных:
 * текстовый
 * двоичный

---
# Дерево файлов

Файлы идентифицируются по имени:
* `int open(const char *path, int oflag, ...)`
* получить аттрибуты: ` int stat(const char *pathname, struct stat *statbuf)`, ...
* записать аттрибуты: `chmod`, `chown`, ...

.def[Дерево файлов] - дерево, задающее иерархическую структуру для файлов, служит для
 * группировки
 * разрешения конфликтов в именовании
 * оптимизации поиска

Структура дерева:
 * файл с данными - лист
 * .def[каталог] - узел, содержащий перечисление дочерних элементов виде списка пар "имя - id дочернего элемента"

C точки зрения хранения, директория является файлом специального типа (т.е. так же является набором блоков)

---
# Дерево файлов (2)

Разные ОС используют разные разделители для элементов пути. Разделительный символ не может использоваться в имени файла.

Для удобства использования, для процесса определяется .def[рабочий (текущий) каталог].
Все имена файлов по-умолчанию интерпретируются как элементы поддерева текущего каталога.

.def[Абсолютный] (от корня дерева) путь указывается специальным образом:
 * `/usr/bin` (Unix)
 * `C:\windows` (Windows)

Каталог содержит специальные записи
 * "." - ссылка на сам каталог
 * ".." - ссылка на родительский каталог

---
# Взаимодействие с деревом

Просмотр каталога:
* `DIR *opendir(const char *name)`
* `struct dirent *readdir(DIR *dirp)`
* `int closedir(DIR *dirp)`

Изменение дерева:
* `int mkdir(const char *path, mode_t mode)`
* `int rmdir(const char *path)`
* `int unlink(const char *path)`
* `int rename(const char *oldpath, const char *newpath)`
* `int link(const char *path1, const char *path2)`

---
# Ссылки

link позволяет создать дополнительную ссылку от произвольного каталога к файлу. Таким образом, "дерево" файлов - на самом деле граф.

ОС реализует подсчёт ссылок на файлы: после unlink файл, если на него больше нет ссылок, удаляется; иначе, счетчик ссылок декрементируется.

Ссылки:
* .def[Жесткие] - записи в каталоге, управляются link/unlink
* .def[Мягкие] - специальные файлы, в которых содержится имя целевого файла

---
# Файловая система

.def[Файловая система] - структура организации каталогов и файлов на блочном устройстве

Одно устройство может быть разделено на логические области - .def[разделы], на каждом - собственная ФС.

Структура файловой системы:
* Суперблок
 * размер ФС
 * размер логического блока
* Информация о свободных блоках
* Корневой каталог
* Файлы и каталоги

---
# Непрерывное размещение

```asciidrawing
                     1         1
 0     3       7     0         5
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
------ ------- ----------------- ...
Файл 1 Файл 2  Свободная область
```

---
# Связный список блоков

```asciidrawing
            +--------+    +--------+    +--------+    +--------+
            |    ----|--->|    ----|--->|    ----|--->|        |
            +--------+    +--------+    +--------+    +--------+
            |        |    |        |    |        |    |        |
 Файловый   | Блок 0 |    | Блок 1 |    | Блок 2 |    | Блок 3 |
   блок        ...           ...           ...           ...
            |        |    |        |    |        |    |        |
            +--------+    +--------+    +--------+    +--------+

Физический       4             7             2             8
   блок
```

---
# Связный список в таблице

```asciidrawing
Физический
      блок
           +---------+
         0 |         |
           +---------+
         1 |         |
           +---------+
         2 |    8    |
           +---------+
         3 |         |
           +---------+
         4 |    7    |  <- Файл A
           +---------+
         5 |         |
           +---------+
         6 |         |
           +---------+
         7 |    2    |
           +---------+
         8 |   -1    |
           +---------+
```

---
# inode (i-узлы)

```asciidrawing
+---------------+
|      ...      |
|               |
+---------------+
| Адрес блока 0 |
+---------------+
| Адрес блока 1 |
+---------------+
| Адрес блока 2 |
+---------------+
| Адрес блока 3 |
+---------------+     +---------------+
|  Адрес блока  |---->| Адрес блока 4 |
|   указателей  |     +---------------+
+---------------+     | Адрес блока 5 |
                      +---------------+
                      | Адрес блока 6 |
                      +---------------+
                      | Адрес блока 7 |
                      +---------------+
                      |      ...      |
                      +---------------+
                      |  Адрес блока  |
                      |   указателей  |
                      +---------------+
```
---
# Журнальная структура

```asciidrawing
+-----------+
| Изменения | <- head
+-----------+
| Изменения |
+-----------+
| Изменения |
+-----------+
| Изменения |
+-----------+
| Изменения |
+-----------+
| Изменения |
+-----------+
| Изменения | <- tail
+-----------+
     ...
```

---
# ВФС

.left[
```asciidrawing
         Запрос
            |
            v
+-----------------------+
|          ВФС          |
+-----------------------+
   |        |        |
   v        v        v
+-----+  +-----+  +-----+
| ФС1 |  | ФС2 |  | ФС3 |
+-----+  +-----+  +-----+
   ^        ^        ^
   |        |        |
   v        v        v
+-----+  +-----+  +-----+
|  У1 |  |  У3 |  |  У1 |
+-----+  +-----+  +-----+
```
]


.def[Виртуальная файловая система] - интерфейс для пользователя (процесса) для взаимодействия с различными ФС.

ВФС представляет одну файловую систему общим корнем. Другие файловые системы могут быть .def[смонтированы] в произвольное место существующей иерархии: дерево файлов смонтированной системы становится доступным в каталоге монтирования.

Так же содержит реализацию типовых частей для ФС:
 * разбиение строк-путей на символы
 * кэширование структуры каталогов

---
# Драйвера ФС

ВФС позволяет легко создавать новые драйвера:
 * ФС для блочных устройств: различные организации на блочном устройстве
 * сетевых ФС: удаленая машина предоставляет доступ к своей ФС
 * псевдо ФС: иерархия каталогов содержится полностью в оперативной памяти или генерируется на лету

Драйвер должен определять функции, позволяющие:
 * опознать ФС
 * смонтировать ФС
 * читать/модифицировать/удалять файлы, каталоги

Развитие идеи использования файловой системы произошло в ОС Plan9:
 * _все_ ресурсы представлены как файлы
 * возможность экспортировать/импортировать поддеревья файлов

---
# FUSE

Filesystem in Userspace

.fitimg[![](FUSE_structure.svg)]

---
# Восстановление после сбоев

Сбой для файловой системы:
 * пропало питание системы
 * пропало устройство
 * устройство некорректно обработало запрос
 * ...

Желательно, чтобы файловая система сохраняла данные и оставалась непротиворечивой:
* по блокам:
 * неучтенный свободный блок
 * блок принадлежит двум файлам
* по файлам:
 * счётчик ссылок не равен реальному количеству ссылок
...

---
# Журналирование

Традиционные ФС позаимствовали у ФС с журнальной структурой механизм предотвращения повреждения данных при сбоях - журналирование.

.def[Журналирование] - поддержание журнала о выполнямых изменениях:
 * перед началом изменения добавить запись в журнал
 * после изменения удалить запись

Восстановление после сбоя:
* проверить текущие записи в журнале, если есть:
 * определить, какие из действий были совершены; откатить их
 * повторить изменения из журнала: требуется, чтобы они были .def[идемпотентными] - позволяли повторное исполнение без нарушения корректности

Журнал может задавать .def[транзакции] - группу действий, совершаемых атомарно. Т.е. после после сбоя состояние системы должно соответствовать состоянию до изменений.

---
# Производительность

* размер блока ФС:
 * маленькие файлы занимают больше места
 * больший объем на устройстве поддерживается
 * меньше уровней в inode
* учёт свободных блоков:
 * список свободных
 * битовая карта
* кэширование блоков устройства в памяти
 * write-back
 * write-through
* опережающее чтение: читать в буфер больше данных, чем сейчас требуется
* планирование ввода/вывода: переупордочивать множество запросов к одному устройству исходя из знаний о его внутреннем устройстве (для жесткого диска - снижать количество перемещений головки диска)
* дефрагментация: переместить блоки файлов в последовательный порядок

    </textarea>
    <script src="slides.js" type="text/javascript"></script>
  </body>
</html>
