<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Взаимное исключение

---
# Состязательная ситуация

.def[Состязательная ситуация] (состояние гонки, race condition) - одновременный доступ одному ресурсу, при котором конечный результат зависит от порядка исполнения.

* Танненбаум, Современные ОС, 2.4
* Herlihy, Shavit The Art of Multiprocessor Programming

Пример: реализация `pipe`

```asciidrawing

process1                 process2
   |                        ^
   |                        |
   +--------> pipe ---------+
       +----------------+
       | char buf[]     |
       +----------------+
       | char *writeend |
       +----------------+
       | char *readend  |
       +----------------+
```

---
# Взаимное исключение

.def[Взаимное исключение] - подход для устранения состязательных ситуаций: предоставить гарантирию монопольного досутпа к ресурсу в течении некоторого времени.

.def[Критическая секция] - участок программы, в котором гарантируюется монопольный доступ.

Свойства взаимного исключения:
* монопольный доступ
* deadlock-freedom - если 2 процесса хотят завладеть ресурсом, то по крайней мере 1 преуспеет
* starvation-freedom - если процесс хочет завладеть ресурсом, то когда-нибудь он преуспеет

```c
	lock();
	write_pipe();
	unlock();
	...
	lock();
	read_pipe();
	unlock();
```

---
# Выключение прерываний

```c
lock() {
	irq_disable();
}

unlock() {
	irq_enable();
}
```

--

* для коротких секций в ядре
* нельзя давать пользователю


```c
lock() {
	sched_disable();
}

unlock() {
	sched_enable();
}
```


---
# Блокирующая переменная

```c
bool locked = false;
lock() {
	while (locked);
	locked = true;
}

unlock() {
	locked = false;
}
```

---
# Блокирующая переменная

```c
atomic test_and_set(ptr) {
	bool old = *ptr
	if (!*ptr) {
		*ptr = true;
	}
	return old;
}
```

```c
bool locked = 0;
lock() {
	while (test_and_set(&locked));
}

unlock() {
	locked = 0;
}
```

---
# Алгоритмически

## lock 1

```c
lock(self) { // 0 or 1
	other = 1 - self
	flag[self] = true
	while (flag[other]);
}

unlock(self) {
	flag[self] = false
}
```
--

## lock 2

```c
process victim = NULL
lock(self) {
	victim = self
	while (victim == self) {}
}

unlock(self) {
}
```

---
# Алгоритм Петерсона

```c
lock(self) {
	other = 1 - self
	flag[self] = true
	victim = self
	while (victim == self && flag[other])
}

unlock(self) {
	flag[self] = false
}
```

Для блокирующей переменной:
1. ожидание активно
2. проблема инверсии приоритета:
   * низкоприоритетный процесс исполненяется в критической секции
   * просыпается высокоприоритеный процесс и пытается зайти в критическую секцию
   * => deadlock или высокоприоритетный процесс оказывается вытеснен низкоприоритетным

---
# Семафор

.def[Семафор] - примитив синхронизации операционной системы; позволяет создавать критическую секцию, в которой может находится не больше определённого количества процессов.

Атомарные операции:
* down - вход в критическую секцию. проверяет счетчик возможных процессов в секции:
  * счётчик процессов больше 0:
      * счетчик декрементируется
      * процесс входит в критическую секцию
  * счётчик равен 0:
      * процесс засыпает, ожидая входа в секцию
* up - выход из критической секции
  * счётчик инкрементируется
  * посылается сигнал пробуждения ожидающему входа процессу (или нескольким)

.def[Mutex] - семафор, позволяющий 1 процесс в критической секции

---

```c
down(semaphore *s) {
    sched_lock();
    while (true) {
        if (0 < cnt) {
            --cnt;
            goto out;
        } else {
            s->q->add(self);
            sched_unlock_wait_relock();
        }
    }
out:
    sched_unlock()
}


```

```c
up(semaphore *s) {
    sched_lock();
    ++cnt;
    other = s->q->pop();
    if (other) {
        wake(other);
    }
    sched_unlock();
}

```
`sched_lock()/unlock()` -- низкоуровневые механизмы создания критических секций, обеспечивают атомарность операций (отосительно друг друга).

---
# Инверсия приоритета

```
LOW:                    HIGH:                   MED:
//work                  //sleep                 //sleep
down(m)
//work
//ready                 //wake
                        //work
//work                  down(m) //block
//ready                                         //wake,work
```
---
# Инверсия приоритета

```
LOW:                    HIGH:                   MED:
//work                  //sleep                 //sleep
down(m)
//work
//ready                 //wake
                        //work
//work,HIGH             down(m) //block
                                                //wake
//up(m),LOW,ready
                        //work
```

.def[Наследование приоритета] - процесс получает максимальный приоритет среди других процессов, ожидающих занятый ресурс.

Sha, Rajkumar, Lehoczky: "Priority Inheritance Protocols: An Approach to Real-Time Synchronization"

---
# Монитор

```c
	down(&sem)
	write_pipe();
	up(&sem);
	...
	down(&sem);
	read_pipe();
	up(&sem);
```
Программист:
 * должен вызвать `up`
 * количество вызовов `up` должно быть `<=` вызовов `down`

.def[Монитор] - примитив синхронизации над объектом, в каждый момент времени монитором объекта владеет не более одного метода.

```
class Pipe {
	public synchronized void write() { ...  }
	public synchronized void read() { ...  }
}
```

---
# Барьер

.def[Барьер] - примитив для синхронизации фаз исполнения.

```c
struct barrier {
    struct mutext m;
    int limit, now;
}
void init(struct barrier *b, int limit) {
    down(&b->m);
    b->limit = limit;
    b->now = 0;
    up(&b->m);
}
void wait(struct barrier *b) {
    down(&b->m);
    if (b->now + 1 < b->limit) {
        ++b->now;
        wait(&b->m);
    } else {
        notify(&b->m);
    }
}
```
Например: [glibc](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=nptl/pthread_barrier_wait.c;h=54bc727e39538ac711c4db6c9901b1ec05222a82;hb=HEAD#l25)

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
