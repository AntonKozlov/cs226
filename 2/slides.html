<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, center, middle

# Операционные системы

## Взаимодействие ОС и программы

---
# ОС - виртуальная машина

```asciidrawing

             OS                        os226

        +------------------+    +------------------+
        |        App       |    |       App        | (процедура)
    +---+------------------+    +------------------+
    |         OS           |    |      OS (VM)     | (программа)
    +------------------+---+    +------------------+
    |     Hardware     |        |     Hardware     | (ВМ хост-ОС)
    +------------------+        +------------------+
```

Как может выглядеть виртуальная машина на ОС ("ОС внутри ОС")?

Для начала:
 * программы - процедуры
 * виртуальная машина совпадает с физической

---
# `gdb hello`

```c
int main(int argc, char *argv[]) {
        printf("Hello, world\n");
        return 0;
}
```

```c
int main(int argc, char *argv[]) {
        const char *msg = "Hello, World!\n";
        write(1, msg, strlen(msg));
        return 0;
}
```

---
# Библиотеки

```sh
$ ls printf.o strcmp.o ...
```

.def[Статическая линковка]:
```sh
$ ar crs libname.a *.o
$ gcc -o main main.c -lname
```
Будут слинкованы только те объектные файлы, которые содержат определения до сих пор неопределённых символов.

Исполняемый файл будет включать всё содержимое объектных файлов. Большинство будут включать большую часть libc.

.def[Динамическая линковка]:
```sh
$ gcc -shared -o libname.so *.o
$ gcc -o main main.c -lname
```

---
# Системные вызовы

* статическая линковка
* динамическая линковка
--

* динамическая диспетчеризация (syscall)
```sh
(gdb) disas write
   ...
   0x000000000043bbea <+10>:    mov    $0x1,%eax
   0x000000000043bbef <+15>:    syscall
   ...
```
Инструкция `syscall` процессора x86-64 генерирует .def[исключение].

---
# Исключения

```asciidrawing
        +--------+       +--------+      +---------+
        |  CPU   |       | Memory |      |   I/O   |
        +--------+       +--------+      +---------+
            ^                ^                ^
            |                |                |
            v                v                v
Bus +---------------------------------------------------
    +---------------------------------------------------
```

.def[Исключение] - событие, при котором процессор переходит на заранее определённый обработчик (процедуру)

1. Синхронные (внутренние)
 1. деление на ноль
 2. ошибки доступа к памяти
 3. инструкции программных исключений
 4. ...
2. Асинхронные (внешние)
 1. прерывания

---
# Режимы работы CPU

```asciidrawing
          +------------------+
          | Пользовательский |
          +------------------+
             |          ^
  Исключение |          | Выход из обработчика
             v          |
          +------------------+
          |    Системный     |
          +------------------+
```

В пользовательском режиме заблокирована часть:
 * инструкций
 * регистров
 * адресов памяти

```asciidrawing
        +--------------+
        |     App      |
    +---+--------------+
    |         OS       |
    +------------------+
    |     Hardware     |
    +------------------+
```

---
# Обработка исключений

Полная последовательность обработки: (* -- реализуется аппаратурой):
1. (*) Сохранение базового контекста CPU
2. (*) Подготовка и переключение в контекст обработки исключения
4. Обработка исключения
5. (*/)Acknowledgement исключения
6. (*/)Восстановление контекста

<!--
3. Сохранение полного контекста (например, код ядра меняет несохраннёную часть контекста => нужно сохранить)
-->

Обработчик исключения может менять контекст.
Так можно возвращать результат.

.def[Системный вызов] - исключение с семантикой вызова (определённой функции ядра).

ОС расширяет машину системными вызовами:


```asciidrawing
        +------------------+
        |        App       |
    +---+------------------+
    |         OS           |
    +------------------+---+
    |     Hardware     |
    +------------------+
```

.def[Ядро] - участок ОС, исполняющийся в системном режиме (привелегированном, режиме супервизора).

---
# Типы ядер ОС

* .def[Монолитные] - все функции находятся в ядре:

 * планировщик
 * драйвера устройств
 * сетевые протоколы, файловые системы
 * реализация системных вызовов ФС, сети,...

 Примеры: Linux, *BSD

* .def[Микроядерные] - только минимальная часть в ядре.

  Большинство функций реализуется реализуется системными процессами, в ядре только:
  * планировщик
  * обработка исключений
  * обмен сообщениями между процессами

  Примеры: MINIX, L4

* .def[Экзоядерные] - ядра нет/только мультиплексоры устройств

---

Так же, как процессор получает исключения, процессы в UNIX получают .def[сигналы].

Часть определения .def[сигнала] - событие получаемое программой при исполнении некорректной инструкции:
 * неопределённая инструкция
 * привелегированная инструкция (только в системном режиме)
 * инструкция с некорректными аргументами (доступ по неправильному адресу, деление на ноль,...)

Поведение по умолчанию: завершить процесс, игнорировать, сгенерировать core файл, ...

Может быть переопределено: вызвать функцию-обработчик.

```c
void hnd(int sig) { ... }
int main() {
        signal(SIGSEGV, hnd);
```
```c
void hnd(int sig, siginfo_t *info, void *ctx) { ... }
int main() {
       struct sigaction act = { .sa_sigaction = sighnd };
       sigaction(SIGSEGV, &act, NULL);
```

---
# Процесс

.def[Процесс] - исполняемая программа:
 * программа и её состояние
 * экземпляр виртуальной машины

Цикл жизни процесса:
1. Создание
2. Выполнение
3. Завершение

Создание процесса:
* Инициализация системы.

 В Unix: ядро запускает первый процесс init -- процесс отвечающий за запуск других процессов
* Существующий процесс создает другой процесс.

 В Unix: системный вызов fork

---
# fork

Системный вызов `fork(2)` создает полную копию вызывающего процесса, за исключением кода возврата системного вызова.

```sh
$ man 2 fork
```

Создаются независимые копии:
 * адресного пространства
 * текущего состояния (набор значений регистров)
 * ресурсов ОС

По коду возврата можно определить, исполняется ли новый или оригинальный процесс.

Неточный пример:

```c
	int res = fork(); // системный вызов
	if (res == 0) {
		// new process
	} else {
		// old process
	}
```
---
# fork

```c
	int res = fork(); // код возврата != 0
	if (res == 0) {
		// new process
	} else {
		// old process, исполняем это
	}
```

```c
	int res = fork(); // код возврата 0
	if (res == 0) {
		// new process, исполняем это
	} else {
		// old process
	}
```

---
# Иерархия процессов

При fork оригинальный и новый процессы становится .def[родителем] и .def[ребенком].

Процессы в системе образуют дерево иерархии.

```asciidrawing
+--------+
| parent |
+--------+
    |
    +---->...
    |
    |
    +---->...
    |
    |     +-------+
    +---->| child |
          +-------+
```

---
# Идентификация процессов

Процессы идентифицируются числом типа `pid_t`

```c
	pid_t parent = getpid(); // получить id текущего процесса
	pid_t child = fork();
	if (child == 0) {
		// child process; child в родителе == getpid()
	} else {
		// parent process
	}
```

---
# exec

Системный вызов `exec` -- заместить текущий процесс новыми, инициализировав его программой с диска

Вместе с `fork`, позволяет создавать процесс с любой программой

example.c:

```c
static int global = 314;
int main(int argc, char *argv[]) {
	printf("%d\n", global);
	return 0
}
```
```c
        ...
	pid_t child = fork();
	if (child == 0) {
		execl("./example", NULL);
	}
        ...
```

---
# Завершение процесса

1. Выход (с кодом завершения):
```
	exit(success ? 0 : 1);
```

2. Получение сигнала:
 * неперехватываемого SIGKILL
 * перехватываемого сигнала без установленного обработчика и поведением по умолчанию "завершение"

<!--
Замечания:
 * существуют перехватываемые сигналы с поведением по умолчанию "игнорировать"
* при установке обработчика можно изменить поведение c "завершения" на произвольное


# Сигналы

Процесс получает сигнал:
 * сгенерированный операционной системой как результат выполнения программы (примерно: внутреннее исключение процессора):
  * SIGSEGV - ошибка изоляции процесса
  * SIGILL - исполнение невалидной инструкции процессора
  * ...
 * посланный другим процессом (очень примерно: прерывание от устройства)

# Подбор процесса
-->

.def[Подбор] -- получение родительским процессом информации о завершении дочернего, в том числе, кода возврата.

Часть ресурсов дочернего процесса не освобождается после его выхода, а сохраняется до подбора:
 * идентификатор процесса
 * память под код возврата

---
# waitpid

Подбор реализуется системным вызовом `waitpid(2)`

```c
	pid_t child = fork();
	if (child == 0) {
		execl("./example", NULL);
	}
	int cstat;
	if (-1 == wait(&cstat)) {
		perror("waitpid");
                ...
	}
	int childcode = WIFEXITED(cstat) ? WEXITSTATUS(cstat) : -1;
```

Выход из `waitpid` родительского процесса в примере происходит только тогда, когда дочерний процесс завершается.

<!--
Может быть отключено флагом `WNOHANG`
-->

---
# Реализация sh

```sh
$ sleep 10 ; sleep 2
```
(fork, exec, wait)

```sh
$ test # shell built-in
$ myfunc() { ... }
$ myfunc
```
(..., но зависит от реализации)

```sh
$ ( echo 1 ; echo 2)
```
(fork, ..., wait)

```sh
$ sleep 10 & sleep 2
```
(fork, exec, ...)

---
# Файловые дескрипторы

Как реализованы перенаправления?

```sh
$ seq 1 100 > temp.txt
$ grep 2 < temp.txt

$ seq 1 100 | grep 2
```

* .def[Файловый дескриптор] -- объект операционной системы поддерживающий файловый интерфейс (`read(2)`, `write(2)`,...).

Для защиты, объекты ОС находятся в адресном пространстве ядра, т.е. недоступны процессу напрямую.

С процессом ассоциирована таблица (массив) файловых дескрипторов, находящаяся так же в адресном пространстве ядра.

Процесс оперирует с файловыми дескрипторами с помощью системных вызовов и индексов дескрипторов в таблице (т.е. косвенно).

---
# "Всё есть файл" (1)

Многие сущности представлены или могут быть представлены в качестве файловых дескрипторов

```asciidrawing
      +----------+
 +--->| keyboard |
 |    +----------+
 |
 |    +---------+
 | +->| display |
 | |  +---------+
 | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```c
	char buf[128];
	int r = read(0, buf, sizeof(buf));
	write(1, buf, r);
```

---
# Создание элементов таблицы

```asciidrawing
      +---------+
   +->| display |
   |  +---------+
   |
   |
   |    +------+
   | +->| file |
   | |  +------+
   | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```c
	int fd = open("test.txt", O_WRONLY);
	write(fd, content...);
```
---
# Изменение таблицы

```asciidrawing
        +------+
   +-+->| file |
   | |  +------+
   | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```c
	int fd = open("test.txt", O_WRONLY);
	dup(fd, 1);
```
---
# Удаление элементов

```asciidrawing
        +------+
   +--->| file |
   |    +------+
   |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```c
	int fd = open("test.txt", O_WRONLY);
	dup2(fd, 1);
	close(fd);
```

---
# `> text.txt`

`fork` копирует таблицу ресурсов.

```sh
$ seq 1 100 > test.txt
```

```c
	...
	pid_t child = fork();
	if (child == 0) {
		close(1);
		int fd = open("text.txt", O_WRONLY);
		assert(fd == 1);
		execl("/usr/bin/seq", "1", "100", NULL);
	}
	if (-1 == wait(NULL)) {
		perror("wait");
	}
```

---
# pipe

```sh
$ seq 1 100 | grep 2
```

Системный вызов `pipe(2)` создает буфер (в ядре ОС) и 2 ассоцированных с ним дескриптора: для записи и для чтения.

```asciidrawing
+---------------+    +-------------+    +--------------+
| pipe write fd |--->| pipe buffer |--->| pipe read fd |
+---------------+    +-------------+    +--------------+
       ^                                       ^
       |                                       |
    +-+-+-+-                                  +-+-+-+-
    +-+-+-+-                                  +-+-+-+-
       1                                       0
............................................................
   +-----------+                             +-----------+
   | process 1 |                             | process 2 |
   +-----------+                             +-----------+

   write(1, ...)                             read(0, ...)
```

---
# Замечания

Так же pipe позволяет реализовать подстановки
```sh
$ echo $(cat -)
```
(вывод `cat` вычитывает через pipe сам интерпретатор)

Для диагностических ошибок выделен файловый дескриптор 2 (STDERR_FILE). Например,
```sh
$ cat notexist | grep 1
cat: notexist: Нет такого файла или каталога
```

Когда в буфере нет данных, читающий процесс приостанавливается. Аналогично, когда буфер полностью заполняется, пприостанавливается пишущий процесс.


<!--
# Исследуем...

Rob Pike, Systems Software Research is Irrelevant:

* ... software is stagnant
* If systems research was relevant, we’d see new operating systems and new languages making inroads into the industry.
* Instead, we see a thriving software industry that largely ignores research, and a research community that writes papers rather than software.
* Change of scale: ... industry tends to do the big, defining projects operating systems, infrastructure, etc. - and small research groups must find smaller things to work on.  Three trends result:
  1. Don’t build, measure. (Phenomenology, not new things.)
  2. Don’t go for breadth, go for depth. (Microspecialization, not systems work.)
  3. Take an existing thing and tweak it.

-->
<!--
# Д/З

Перенести ваш шелл под Linux:

```
$ echo Hello, World
Hello, World
```
```
$ echo test1; echo test2
test1
test2
```

Добавить перенаправление pipe

```
$ seq 1 100 | grep 2 | grep 0
```

Можно считать, что и все программы лежат в `/usr/bin`

https://github.com/AntonKozlov/eduos/tree/next/shell
```
$ make -C shell test
```
```
$ (cd shell; make test)
```
-->

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
