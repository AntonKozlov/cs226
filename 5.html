<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="slides.css">
    <script src="remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Управление памятью

---
# Литература

* Кнут, Искусство программирования, т.1, 2.5
* Wilson, Johnstone,... Dynamic Storage Allocation

---
# Управление памятью

.def[Управление памятью] - поддержка информации о блоках свободной/занятой памяти и удовлетворение запросов:
 * выделение памяти опредлённого размера
 * (опционально) освобождение ранее выделенной памяти

Существенные ограничения:
* Запросы поступают online (последующие запросы неизвестны)
* Выделенная память не может быть самостоятельно
 * отозвана
 * (опционально) перемещена

---
# Типы и примеры

Автоматическое управление памятью:
 * сборка мусора
 * подсчёт ссылок

Ручное:
 * Выделение в куче (malloc/free)
 * специализированные аллокаторы

Статическое:
 * глобальные данные
 * выделение на стеке

Сверху вниз уменьшается гибкость, но и уменьшаются накладные расходы, увеличивается предсказуемость (в смысле real-time)

---
# Область изучения

Ручное выделение, обязательно:
 * освобождение ранее выделенной памяти
 * память не может быть перемещена

.def[Стратегия] - направлена на эксплуатирование особенностей в потоке запросов.

.def[Политика] - процедура размещения блоков памяти, допустимых стратегией.

.def[Механизм] набор алгоритмов и стурктур данных, реализующих политику.

Основные метрики:
 * фрагментация памяти
 * скорость выделения/освобождения

Метрики подсчитываются на записях .def[трасс] (последовательностях запросов) реальных программ.

---
# Фрагментация

.def[Внешняя] - наличие достаточного количества свободной памяти, которая не может быть выделена. Например, много несмежных блоков маленького размера. Причины появления:
 * точечные освобождения
 * смена фаз исполнения программы

.def[Внутренняя] - выделенный блок памяти больше, чем запрашиваемый. Причины появления:
 * отсутствует свободный блок подходящего размера
  * большие блоки могут быть разделены при удовлетворении запроса. После, смежные свободные блоки могут сливаться - превращаться в свободный блок большего размера
 * реализация не поддерживает блоки меньшего размера
 * политика не разделяет блоки, чтобы снизить внешнюю фрагментацию

---
# Последовательный поиск

Свободные блоки находятся в списке.

```asciidrawing

         free_list
         |
         v
+-------+----+---+---+--------------+----+---+---+
|#######|next|len|...|##############|NULL|len|...|
+-------+----+---+---+--------------+----+---+---+
           |                           ^
           |                           |
           +---------------------------+
```

Выделение: выбираем один из блоков, удаляем из списка; если блок больше запроса, то создаем новый свободный блок из остатка и добавляем в список.

Освобождение: добавляем в список свободных. 

---
# Последовательный поиск
Выбор свободного блока:
* First Fit (*)
* Best Fit (*)
* Next Fit
* Worst Fit, Optimal Fit, Half Fit

Добавление в список свободных:
* LIFO
* FIFO (*)
* Address Ordered (*)

Проблемы масштабирования: с ростом количества блоков время поиска растёт

---
# Слияние

.def[Слияние] - объединение освобожденного блока с соседними свободными. 

```asciidrawing

         free_list        
         |            free()
         v            v
+-------+----+---+---+--------------+----+---+---+
|#######|next|len|...|##############|NULL|len|...|
+-------+----+---+---+--------------+----+---+---+
           |                           ^
           |                           |
           +---------------------------+
```
```asciidrawing

         free_list        
         |
         v
+-------+----+---+-------------------------------+
|#######|NULL|len|...............................|
+-------+----+---+-------------------------------+
           |                           ^
           |                           |
           +---------------------------+
```

---
# Замечания

"Небольшой" остаток можно не отделять: повышает внутреннюю фрагментацию, уменьшает внешнюю.

Слияние - дорогая операция (требует прохода по списку). Для удешевления, можно упорядочить свободные по адресам и проходить только часть списка.

Для освобождения нужно знать размер занятой области:
 * обязать пользователя указывать его
 * хранить размер выделенной области

```asciidrawing
Блок
|    Выделенная память
|    |
v    v
+----+---------------
|size| 
+----+---------------
```


---
# Граничные маркеры


```asciidrawing
Блок
|         Выделенная память
|         |
v         v
+----+---+-----------+----+---+
|size|tag|           |size|tag|
+----+---+-----------+----+---+
```

tag: бит занят/свободен

По адресу блока (занятого или свободного) можно определить определить соседние блоки. Позволяет ускорить слияние.

size + tag можно хранить в одном слове.

---
### Двоичные близнецы

Вариант Linux'а:


```asciidrawing
  +---+---+   +-+   +-+
0 |map|   |<->| |<->| |
  +---+---+   +-+   +-+
1 |map|   |
  +---+---+   +-------+
2 |map|   |<->|       |
  +---+---+   +-------+
```
Память управляется блоками по степеням двойки. Для каждой степени:
 * список свободных 
 * битовая карта, где каждому биту соответствует пара блоков:
  * 1 - оба заняты или свободны

Легко вычислить .def[близнеца] и определить его состояние => легко сливать
```
buddy_block_addr(block_addr, size) = block_addr ^ (1 << size)
```

Состояние (занят/свободен) хранится вне блоков: низкая внутренняя фрагментация.

Но не сливает смежные блоки, не являющиеся близнецами.

---
# Метод близнецов

Частный случай раздельных свободных (best fit) + быстрый способ слияния.

Большая фрагментация по сравнению с другими методами
* Двоичные близнецы
* Фибоначчи
* Взешенные

---
# Раздельные списки свободных

.def[Раздельный поиск] - отдельный список свободных блоков для каждого
 * размера 
 * размера, округляемого вверх
 * класса размеров


.def[Раздельное хранение] - объекты разных размеров размещаются в разных областях => не нужно хранить размер каждого, только один размер для области

---
# Индексированный поиск

Используются структуры данных для поиска блока согласно требуемым характеристикам.

Пример: Best Fit по двоичному дереву, упорядоченному по размеру.

#### Поиск по битовой шкале

Одна или несколько битовых шкал, хранящих пометки занят/свободен.

---
# Отложенное слияние

После освобождения сразу же возможно выделение => слитые блоки возможно сразу же придется разделить.

Можно не сливать сразу, а поддерживать несколько списков для недавно освобожденных блоков разных небольших размеров - кэш для аллокатора.

Очищать список:
 * частично или полностью 
 * периодически/по исчерпанию основной кучи/по достижению предела длины
 * ...

Пример: Quick Fit

---
# Специализированные аллокаторы

* obstack
* pool
* slab

Литература:
 * Corbet, Rubini, Linux Device Drivers, Third Edition, ch. 8
 * Gorman, Understanding The Linux Virtual Memory Manager, ch. 8
 * Bonwick, The Slab Allocator 


---
# Obstack

Стек-подобная структура (“object stack”).

Выделение - передвижение вершины obstack. Освобождение всего obstack.

Свойства: быстрое, эффективное, удобное, но опасное.

---
# pool (Embox)

```
POOL_DEF(my_pool, my_obj, OBJ_CNT);

void *pool_alloc(struct pool *pl);
void pool_free(struct pool *pl, void *obj);
```

---
# slab

```
struct foo {
	kmutex_t m;
	kcondvar_t cv;
	...
};

```

slab: 
 * информация о типе объектов: размер, функция-конструктор,...
 * список кеш-блоков, каждый:
  * память под N объектов
  * состояние (полный/частично-свободный/свободный), статистика

* DRY
* учитывается в отладочной информации и статистике выделения
* позволяет другим подсистемам запрашивать память из SLAB

---
# slab - операции

##### To allocate an object:
```
if (there’s an object in the cache) {
	take it (no construction);
} else {
	allocate memory;
	construct the object;
}
```

##### To free an object

`return it to the cache (no destruction required);`

##### To reclaim memory from the cache:
```
take some objects from the cache;
destroy the objects;
free the underlying memory;
```

---
# Влияние на аппаратный кеш

Размещение памяти под объекты влият на загрузку шины между процессором и памятью

```asciidrawing
0x0     0x20    0x40
+-------+-------+-------+
| obj 1 | obj 2 | obj 3 | (cache-block 0)
+-------+-------+-------+

0x0     0x20    0x40
+-------+-------+-------+
| obj 1 | obj 2 | obj 3 | (cache-block 1)
+-------+-------+-------+
```

Решение - раскраска кэша.

```asciidrawing

  0x4     0x24    0x44
+-+-------+-------+-------+
|.| obj 1 | obj 2 | obj 3 | (cache-block 1)
+-+-------+-------+-------+
```


    </textarea>
    <script src="slides.js" type="text/javascript"></script>
  </body>
</html>
