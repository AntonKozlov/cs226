<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="slides.css">
    <script src="remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Операционные системы

#### Процессы

---
# Разбор Д/З

https://github.com/embox/embox/blob/master/src/lib/shell/tokenizer.c

---
# Определения

* .def[Адресное пространство] (процесса) - множество адресов в памяти, к которым процесс может запросить доступ

В адресном пространстве процесса находятся все данные приложения и его код.

Для защиты, память ядра не доступна для процессов для поддержание изоляции.

---
# Жизнь процесса

1. Создание
2. Выполнение
3. Завершение


---
# Создание

1. Инициализация системы. 
 
 В Unix: ядро запускает первый процесс init -- процесс отвечающий за запуск других процессов
2. Существующий процесс создает другой процесс. 
 
 В Unix: системный вызов fork

---
# fork

Системный вызов `fork(2)` создает полную копию вызывающего процесса, за исключением кода возврата системного вызова. 

```
$ man 2 fork
```

Создаются независимые копии:
 * адресного пространства
 * текущего состояния (набор значений регистров)
 * ресурсы ОС

По коду возврата можно определить, исполняется ли новый или оригинальный процесс.

Неточный пример:

```
	int res = fork(); // системный вызов
	if (res == 0) {
		// new process
	} else {
		// old process
	}
```

---
# fork

```
	...
	int res = fork(); // код возврата 0
	if (res == 0) {
		// new process, исполняем это
	} else {
		// old process
	}
```
 --- 

```
	...
	int res = fork(); // код возврата _не_ 0
	if (res == 0) {
		 // new process
	} else {
		// old process, исполняем это
	}
```

---
# Иерархия процессов

При fork оригинальный и новый процессы становится .def[родителем] и .def[ребенком].

Процессы в системе образуют дерево иерархии.

```asciidrawing
+--------+
| parent |
+--------+
    |
    +---->...
    |
    |
    +---->...
    |
    |     +-------+
    +---->| child |
          +-------+
```

---
# Идентификация процессов

Процессы идентифицируются числом типа `pid_t`

```
	pid_t parent = getpid(); // получить id текущего процесса
	pid_t child = fork();
	if (child == 0) {
		// child process; child в родителе == getpid()
	} else {
		// parent process
	}
```

---
# exec

Системный вызов `exec` -- заместить текущий процесс программой с диска, с инициализацией начального состояния

Используется вместе с `fork` для создания нового процесса, исполняющего другие програмыы, а не только копии оригинального процесса.

example.c:

```
static int global = 314;
int main(int argc, char *argv[]) {
	printf("%d\n", global);
	return 0
}
```
 ---
```
	...
	pid_t child = fork();
	if (child == 0) {
		execl("./example", NULL);
	}
	...
```

---
# Завершение процесса

1. Выход (с кодом завершения):
```
	const int success = 0;
	const int error = 1; // Любой не 0
	exit(success);
```

2. Получение сигнала:
 * неперехватываемого SIGKILL
 * перехватываемого сигнала без установленного обработчика и поведением по умолчанию "завершение"

Замечания:
 * при установке обработчика можно изменить поведение c "завершения" на произвольное
 * существуют перехватываемые сигналы с поведением по умолчанию "игнорировать"

---
# Сигналы

Процесс получает сигнал:
 * сгенерированный операционной системой как результат выполнения программы (примерно: внутреннее исключение процессора):
  * SIGSEGV -- ошибка изоляции процесса
  * SIGILL -- исполнение невалидной инструкции процессора
  * ...
 * посланный другим процессом (очень примерно: прерывание от устройства)


---
# Подбор процесса

* .def[Подбор] -- получение родительским процессом информации о завершении дочернего, в том числе, кода возврата.

Часть ресурсов дочернего процесса не освобождается после его выхода, а сохраняется до подбора:
 * идентификатор процесса
 * память под код возврата

---
# waitpid

Подбор реализуется системным вызовом `waitpid(2)`

```
	pid_t child = fork();
	if (child == 0) {
		execl("./example", NULL);
	}
	int cstat;
	const int waitflags = 0;
	if (-1 == waitpid(child, &cstat, waitflags)) {
		perror("waitpid");
	}
	int childcode = WIFEXITED(cstat) ? WEXITSTATUS(cstat) : -1;
```

Выход из `waitpid` родительского процесса в примере происходит только тогда, когда дочерний процесс завершается.

Может быть отключено флагом `WNOHANG`

---
# Перенаправления

```
$ seq 1 100 > temp.txt
$ grep 2 < temp.txt
```

```
$ seq 1 100 | grep 2
```

---
# Файловые дескрипторы

* .def[Файловый дескриптор] -- объект операционной системы поддерживающий файловый интерфейс (`read(2)`, `write(2)`,...). 

Для защиты, объекты ОС находятся в адресном пространстве ядра, т.е. недоступны процессу напрямую.

С процессом ассоциирована таблица (массив) файловых дескрипторов, находящаяся так же в адресном пространстве ядра. 

Процесс оперирует с файловыми дескрипторами с помощью системных вызовов и индексов дескрипторов в таблице.

---
# "Всё есть файл" (1)

Многие сущности представлены могут быть представлены в качестве файловых дескрипторов

```asciidrawing
      +----------+
 +--->| keyboard |
 |    +----------+
 |
 |    +---------+
 | +->| display |
 | |  +---------+
 | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	char buf[128];
	int r = read(0, buf, sizeof(buf));
	write(1, buf, r);
```

---
# Создание элементов таблицы

```asciidrawing
      +---------+
   +->| display |
   |  +---------+
   |
   |
   |    +------+
   | +->| file |
   | |  +------+
   | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	int fd = open("test.txt", O_WRONLY);
	write(fd, content...);
```
---
# Изменение таблицы

```asciidrawing
        +------+
   +-+->| file |
   | |  +------+
   | |
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	int fd = open("test.txt", O_WRONLY);
	dup(fd, 1);
```
---
# Удаление элементов

```asciidrawing
        +------+
   +--->| file |
   |    +------+
   |  
+-+-+-+-
+-+-+-+-       kernel-space
............................
+---------+      user-space
| process |
+---------+
```
```
	int fd = open("test.txt", O_WRONLY);
	dup2(fd, 1);
	close(fd);
```

---
# `> text.txt`

`fork` копирует таблицу ресурсов.

```
$ seq 1 100 > test.txt
```

```
	...
	pid_t child = fork();
	if (child == 0) {
		close(1);
		int fd = open("text.txt", O_WRONLY);
		assert(fd == 1);
		execl("/usr/bin/seq", "1", "100", NULL);
	}
	if (-1 == wait(NULL)) {
		perror("wait");
	}
```

---
# pipe

```
$ seq 1 100 | grep 2
```

Системный вызов `pipe(2)` создает буфер (в ядре ОС) и 2 ассоцированных с ним дескриптора: для записи и для чтения. 

```asciidrawing
+---------------+    +-------------+    +--------------+
| pipe write fd |--->| pipe buffer |--->| pipe read fd |
+---------------+    +-------------+    +--------------+
       ^                                       ^ 
       |                                       |
    +-+-+-+-                                  +-+-+-+-
    +-+-+-+-                                  +-+-+-+-
       1                                       0
............................................................
   +-----------+                             +-----------+
   | process 1 |                             | process 2 |
   +-----------+                             +-----------+

   write(1, ...)                             read(0, ...)
```

---
# Замечания

pipe позволяет реализовывать программы-фильтры (grep, sed, ...).

Для диагностических ошибок выделен файловый дескриптор 2 (STDERR_FILE). Например,
```
$ cat notexist | grep 1
cat: notexist: Нет такого файла или каталога
```

Когда в буфере нет данных, читающий процесс приостанавливается. Аналогично, когда буфер полностью заполняется, пприостанавливается пишущий процесс.

---
# Д/З

Перенести ваш шелл под Linux:

```
$ echo Hello, World
Hello, World
```
```
$ echo test1; test2
test1
test2
```

Добавить перенаправление pipe

```
$ seq 1 100 | grep 2 | grep 0
```

Можно считать, что и все программы лежат в `/usr/bin`
    </textarea>
    <script src="slides.js" type="text/javascript"></script>
  </body>
</html>
