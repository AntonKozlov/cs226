<!DOCTYPE html>
<html>
  <head>
    <!--<title>My Awesome Presentation</title>-->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../slides.css">
    <script src="../remark.min.js"></script>
  </head>
  <body>
    <textarea id="source">

class: title, title, center, middle

# Операционные системы

## Таймеры и прерывания

---
# Измерение времени

* Ограничение времени исполнения задачи
* Поддержка запроса sleep

---
# Аппаратный таймер

Устройство, отслеживающее время.

```asciidrawing

+---------+     +---------+
| counter |     | counter |     ...
+---------+     +---------+
                | reload  |
                +---------+
```
* counter: декрементируется аппаратурой с определённой частотой (например, 1Mhz)
* reload: (если есть и используется) новое значение counter, загружается аппаратурой автоматически по обнулению counter.

Когда counter становится равным `0`, генерируется прерывание.

Из частоты обновления counter определяется время возникновения прерывания (например, 20ms <-> counter = 20 * 10.sup[3])

Reload повышает точность периодической генерации прерываний за счёт отсутствия задержки программной записи в сounter во время прерывания.

---
Аппаратный таймер может быть сложнее:

.fitimg[![](pwm-output-mode.jpg)]

---
# Использование 1

Отмерение временных интервалов:
 * периодических
 * однократных

Пример: ограничение времени выполнения задачи.

После выбора новой задачи, перед её исполнением, программируем таймер, например, на 100ms.

Когда задача завершается, останавливаем таймер.

Если прерывание генерируется раньше, останавливаем задачу принудительно.

---
# Программные таймеры

Аппаратный таймер может отслеживать только 1 период времени.
```
sleep(100, hnd);        sleep(200, hnd);        while(true) { }
```

Программные таймеры - множество таймеров, основанных на одном аппаратном.

```asciidrawing
+- - - - - - -+    +- - - - - - -+           +- - - - - - -+
|  counter 1  |    |  counter 2  |           |  counter N  |
+- - - - - - -+    +- - - - - - -+    ...    +- - - - - - -+
|     ...     |    |     ...     |           |     ...     |
+- - - - - - -+    +- - - - - - -+           +- - - - - - -+

```

Каждый программный таймер содержит собственный обработчик прерывания (.def[программный] == виртуальный).

Задача обработчика прерывания аппаратного таймера: для всех программных таймеров
 * поддерживать counter
 * вызывать обработчики прерываний

---
# Реализация

Очередь - двусвязный список:
 * queue.h (BSD)
 * list.h (Linux)
 * dlist/slist (Embox)

Программируем reload = минимальным измеримым отрезоком времени (например, 1ms).

Тогда, counter программного таймеры содержит количество отрезков, оставшихся до истечения программного таймера (например, 20 для 20ms с отрезком в 1ms)

По прерыванию от аппаратного таймера декрементируем счётчики каждого таймера, если получается ноль, значит таймер истёк.

---
# Оптимизации

## Оптимизация обработки

Упорядочить таймеры по возрастанию срока срабатывания. Значения счётчиков (C.sub[i]) - функция от срока срабатывания (T.sub[i])

C.sub[0] = T.sub[0]

C.sub[i] = T.sub[i] - T.sub[i-1]

## Оптимизация прерываний

Известно самое раннее время срабатывания, можно настроить аппаратный таймер на это время (а не на минимальное измеримое время)

Уменьшение количества прерываний:
* ускоряет систему
* экономит энергию

---
# Использование 2

Определение текущего реального времени

Пример: `gettimeofday(2)`

Узнать текущее время
 * загрузить из Real Time Clock (RTC)
 * получить по Network Time Protocol (NTP)

По каждому прерыванию от аппаратного таймера подсчитывать прошедшее время (точность = минимальному измеримому отрезку)

Для получения прошедшего времени между прерываниями обращаться к counter аппаратного таймера

---
# Прерывание

.def[Прерывание] - исключение процессора, посылаемое оборудованием для оповещения о наступлении события

```asciidrawing
          +-----+    irq
          | USR +--------------+
          +--+--+              |
             |                 |
     syscall |                 |
             v                 v
          +-----+           +-----+
          | SYS +- - - - - >| IRQ |
          +-----+    irq    +-----+
```

Аппаратура выполняет (как и в системном вызове):
* приостановление текущего потока управления, сохранение информации для возврата в него (на текущий стек/на выделеныей стек/на специальный набор регистров)
* смену режима работы процессора на режим IRQ:
	* прерывания выключаются
	* включается самый слабый режим защиты
* переход на функцию-обработчик

---
# Обработчик таймера 1

Пишем функцию-обработчик:
* узнать причину прерывания (тип, номер прерывания)
* (*) произвести необходимые действия для конкретного номера прерывания
 * Для таймера: обойти множество программных таймеров, декрементировать счётчики, вызвать обработчики истёкших программных таймеров
* сообщить оборудованию, что прерывание обработано (позволяет оборудованию генерировать новые прерывания)
* провести действия по восстановлению контекста для выхода из прерывания (в отличие от системного вызова, здесь контекст нельзя менять!)

Проблема:
 * обработчик прерывания выполняется в режиме IRQ, прерывания выключены
 * пункт (*) может быть очень долгим

Почему это плохо?

---
# Обработка в 2 этапа

Решение: Разделить обработку прерывания на 2 части

1. .def[top half] - критическая обработка прерывания, прерывания выключены
	1. узнать номер прерывания
	2. провести минимально-необходимые действия по обработке прерывания, сохранить информацию o дальнейших действиях
	3. сообщить оборудованию “обработано”
	4. подготовить более строгий контекст (с включенными прерываниями) и перейти в него
2. .def[bottom half] - отложеная обработка, прерывания включены
	1. получить информацию о неоконченой обработке
	2. провести оставшиеся действия
	3. переключиться в изначальный прерванный контекст

---
# Обработчик таймера 2

1. top half
	1. узнать номер прерывания, он соответствует таймеру
	2. настроить новый период прерывания
	3. включить прерывания
2. bottom half
	1. обойти множество программных таймеров, декрементировать счётчики
	2. вернуться из прерывания

    </textarea>
    <script src="../slides.js" type="text/javascript"></script>
  </body>
</html>
